# 一、页面置换

## 1. 页面置换机制

1. **磁盘提供一块空间**用来保存置换出来的页面（一般为1.5~2倍物理内存）
2. 当页面发生置换时，需要将该**页面对应的所有页表项的存在位置0**，并且**将最终物理地址修改成磁盘扇区地址**
3. **内存访问异常处理**：访问被置换出来的页面异常 -> 检查该地址是否是线程的合法地址 -> 从页表项中找到对应磁盘扇区取出其页面到空闲的物理内存中 -> 修改页表项的物理页号和存在位为1 -> 返回用户抛出异常的指令重新执行（之后TLB会进行缓存）

## 2. 页面置换策略

### 1. FIFO

通过**队列/链表**来维护所有页面：当一个页面被访问时，操作系统将该页面的地址加入到队列中，如果物理页面满了，就将**队列头部的页面弹出**，将其对应的页面置换出去，然后再加入到队列末尾

#### Belady异常现象

当队列长度增大（页面总数量增多），可能会出现更多的缺页异常

### 2. LRU

#### 1. 硬件计数器

1. 硬件维护一个**计数器**，同时**页表中维护一个时间段**，硬件每次解析地址的时候都更新页表中该时间段的值
2. 需要换页的时候操作系统查询所有页表得到每个页面的时间段，将最小的置换出去

缺点：硬件要求高、计数器溢出、页表项扩大、耗时

#### 2. 链表维护

操作系统通过维护一个链表，每个节点存储着对应的页地址，如果**访问到某个页就将该节点放到链表头**（如果已存在就移动，不存在就直接创建），置换的时候**将链表尾部节点的页面置换**出去

缺点：维护链表消耗内存、每次访问一个地址都需要查找链表和修改链表耗时

### 3. Clock

近似 LRU，通过**页表项中的访问位和脏位**来实现

1. 操作系统将所有**页表项通过循环链表**方式连接起来
2. 当cpu访问一个地址时会将页表中的访问位置1，如果写值就将脏位置1
	* 脏位作用：操作系统访问磁盘文件时会将文件加载到内存缓冲区中，如果写过了该文件在内存中内容，就需要将其重新放回到磁盘中
3. 当需要页面置换时，操作系统就遍历循环链表，每遍历一个页表项就将其访问位置0，置换优先级（高到低）：
	1. 访问位=0，脏位=0
	2. 访问位=1，脏位=0
	3. 访问位=1，脏位=1

### 4. 工作集

根据时间和空间局部性原理，**维护近期时间访问最多的页面作为工作集**，置换的时候就换出不在工作集中的页面