# 一、进程分类

* **实时进程**：需要及时响应的进程
	* 一般是需要用户手动设置该进程是否为实时进程，例如一些网页、游戏等
* **普通进程**：不需要及时响应

# 二、进程优先级和nice值

## 1. 查看及修改

`ps -l` 可以查看进程的优先级、`nice`值等

* 进程的 `priority` 值越大，优先级越低，能得到cpu调度时间越少
	* 实时进程：0 ~ 99
	* 普通进程：100 ~ 139
* 进程的 `nice` 值越高，优先级越低
	* -20 ~ 19

`nice`值可以静态设置和更改，会影响优先级，修改进程 `nice` 值的方法：

1. `nice -n 值 进程名`
2. `renice -n 值 -p pid`

## 2. 静态优先级和动态优先级

* 静态优先级：`nice`值决定，用户可以设置和修改
* 动态优先级：内核决定，会自动修改进程优先级

# 三、Linux调度器

## 1. O(n) 调度器

通过链表形式将所有进程连接起来，找到优先级最高的进程来调度，需要遍历所有进程 -> O(n)复杂度

## 2. O(1) 调度器

通过**位图 + 链表**形式，位图中每一位代表一个优先级，每一位都有对应的进程链表，如果该优先级有进程就置1；查找的时**候查找位图中第一个有值的位**，然后**从该位对应的链表中获取进程**来调度 -> O(1)

* `active` 字段：正在等待执行的进程的位图+链表
	* 进程执行过一次就会被放入到 `expired` 字段的链表中，当所有进程都执行过一次，就需要交换 `active` 和 `expired` 指针
* `expired` 字段：执行过一个时间片的进程的位图+链表

![[Pasted image 20240317174907.png]]

因为需要在位图中查找第一个有值的位，所以其**优先级的值越小越先被调度**，即优先级越高

## 3. CFS 调度器

通过分时间片给进程执行（时间片到了就切换进程），但是选择哪个进程来执行是通过 `vruntime` 决定的：

* CFS使用**红黑树**来存储要调度的进程，键为 `vruntime`，越小的越先被调度（最左节点）
* 维护一个**指针指向最左节点**，这样在查询的时候时间复杂度为 O(1)
* `vruntime += 实际运行时间 * 1024 / 进程权重`，进程权重是根据 `nice` 值决定的，`nice`值越大，进程权重越小，`vruntime`增加的越多，优先级下降越多
* 维护一个`min_vruntime`为当前红黑树最小进程的 `vruntime`新进程，在加入新进程的时候其 `vruntime = min_vruntime`，这样可以让新进程先执行，同时又不会导致新进程 `vruntime` 过小占用老进程执行时间
* 对于被唤醒的进程也会减少 `vruntime` 来提供更大的优先级，使得**交互式进程能更快被响应**

![[Pasted image 20240317181449.png]]

相较于 O(1) 调度器优点：

1. 更公平：每个进程尽可能共享cpu时间，而且优先级更高的会先被调度
2. 动态优先级调整

## 4. 调度器执行优先级

1. **实时进程**调度器：先通过 `SCHED_FIFO` 或 `SCHED_RR` 调度策略调度实时进程
2. **普通进程**调度器：当没有实时进程需要调度的时候就是用 `CFS` 调度器调度普通进程