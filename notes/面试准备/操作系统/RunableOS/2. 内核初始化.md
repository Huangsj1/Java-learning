```rust
// os/src/main.rs
pub fn rust_main() -> ! {
	// 只保留一个cpu执行
    let hart_id = hart_id();
    if hart_id != 0 {
        loop {}
    }else{
    // 清除.bss段未初始化的全局/静态变量
    clear_bss();
    // ... 打印信息
    
    // 1.初始化内存
    mm::init();
    mm::remap_test();  // 测试虚拟内存是否有效
    // 2.初始化trap部分
    trap::init();
    trap::enable_timer_interrupt();  // 开启时钟中断
    timer::set_next_trigger();       // 设置下一次时钟中断时间
    // 3.初始化文件系统
    fatfs::fs_init();
    // 4.添加初始进程
    task::add_initproc();
    // 5.挑选线程执行（会一直循环挑选下一个线程）
    task::run_tasks();
    panic!("Unreachable in rust_main!");
    }
}

```

# 一、内存初始化

`main()` 函数会调用 `mm::init()` 来进行内存的初始化（在这之前静态全局变量的初始化都会执行完成）：

1. 初始化内核堆：将在 `.bss` 段开辟的一段静态数组变量的空间交给 `HEAP_ALLOCATOR` 作为堆空间进行管理
2. 初始化物理页帧分配器：将内核结束地址到 `0x80800000` 之间作为物理页帧来进行分配
3. 开启分页：将内核根页表的物理地址（和虚拟地址相一样）放到 `satp`中，同时刷新TLB快表缓存 `sfence.vma`

```rust
// os/src/mm/mod.rs
pub fn init() {
    heap_allocator::init_heap();
    frame_allocator::init_frame_allocator();
    KERNEL_SPACE.exclusive_access().activate();
}
```

这里讨论的是 `mm` 下的内存的初始化，这时候还没有（用户）进程/线程，**只有初始时的内核主线程**，所以还没有对各个线程的内核栈、用户栈、`TrapContext` 进行分配，在 `task` 部分会介绍

# 二、trap初始化

设置 `stvec` 寄存器的值为 `trap_from_kernel()` 函数，里面直接 `panic`（因为暂时不允许在内核态中再被中断/发生异常）

```rust
// os/src/trap/mod.rs
pub fn init() {
    set_kernel_trap_entry();
}
  
fn set_kernel_trap_entry() {
    unsafe {
        stvec::write(trap_from_kernel as usize, TrapMode::Direct);
    }
}

pub fn trap_from_kernel() -> ! {
    use riscv::register::sepc;
    println!("stval = {:#x}, sepc = {:#x}", stval::read(), sepc::read());
    panic!("a trap {:?} from kernel!", scause::read().cause());
}
```

# 三、文件系统初始化

在**初始化了静态全局变量 `FATFS`** 之后就**将fats文件系统读取到了操作系统**中，然后通过下面的获取**构造根目录并且展示根目录下所有文件/文件夹**来进行初始化

```rust
// os/src/fats/mod.rs
pub fn fs_init() {
    root_dir().ls();
}

pub fn root_dir() -> Inode {
    Inode::Dir(DirEntry::root_dir(FATFS.bpb.root_dir_first_cluster))
}
```

# 四、进程和线程初始化

到目前为止都还没有进程，于是下面开始创建第一个进程和其主线程

通过静态全局变量在文件系统中打开 `initproc` 对应的用户程序，读取所有的ELF文件信息，并用来创建其 `PCB`

```rust
// os/src/task/mod.rs
lazy_static! {
    pub static ref INITPROC: Arc<ProcessControlBlock> = {
        let inode = open_file("initproc", OpenFlags::RDONLY).unwrap();
        let v = inode.read_all();
        ProcessControlBlock::new(v.as_slice())
    };
}

pub fn add_initproc() {
    let _initproc = INITPROC.clone();
}
```

第一个进程和主线程的创建：

1. `MemorySet::from_elf()`：从ELF文件中**构建虚拟用户空间**
	* 包括了**映射 `Trampoline` 和分配物理页帧来映射 `sections` 段**
2. `pid_alloc()`：分配**进程id**
3. 创建 `PCB` 结构，并分配了三个fd（标准输入、标准输出、标准输出）
4. 创建 `TCB` 结构：分配**用户栈、`TrapContext`、内核栈**
	* 里面的 `TaskContext` 也已经设置好了，返回到 `trap_return()` 方法中
	* 内核栈是在物理页帧中分配和在**内核中进行间接映射**的
1. 填充 `TrapContext` 中的内容
2. 将当前主线程**加入到就绪队列**中

