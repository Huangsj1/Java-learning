# 一、用户启动

## 1. 用户镜像生成

用户程序也是通过编译链接成可执行文件，然后丢弃元信息得到**二进制 `.bin` 镜像文件**，**每个用户程序都静态链接用户库 `lib.rs` 文件**

### 1. 库文件源代码

1. 回到用户空间的时候首先到的是库函数 `_start()` 中，里面进行堆的设置（设置在全局静态数组变量中），然后获取并构造参数给实际用户 `main()` 方法使用
2. 跳转到用户 `main()` 函数中

```rust
pub extern "C" fn _start(argc: usize, argv: usize) -> ! {
	// 设置用户堆在静态全局数组变量里面
    unsafe {
        HEAP.lock()
            .init(HEAP_SPACE.as_ptr() as usize, USER_HEAP_SIZE);
    }
    let mut v: Vec<&'static str> = Vec::new();
    // 根据参数地址获取所有参数放到 v数组 中返回给用户主函数的argv参数
    for i in 0..argc {
        let str_start =
            unsafe { ((argv + i * core::mem::size_of::<usize>()) as *const usize).read_volatile() };
        let len = (0usize..)
            .find(|i| unsafe { ((str_start + *i) as *const u8).read_volatile() == 0 })
            .unwrap();
        v.push(
            core::str::from_utf8(unsafe {
                core::slice::from_raw_parts(str_start as *const u8, len)
            })
            .unwrap(),
        );
    }
    // 跳转到用户的主函数
    exit(main(argc, v.as_slice()));
}

// 这里的主函数不会被执行，被执行的main函数是用户的main函数
#[linkage = "weak"]
#[no_mangle]
fn main(_argc: usize, _argv: &[&str]) -> i32 {
    panic!("Cannot find main!");
}
```

### 2. 修改链接脚本

所有用户的虚拟地址都是从 `0x10000` 开始

```asm
OUTPUT_ARCH(riscv)
ENTRY(_start)

BASE_ADDRESS = 0x10000;

SECTIONS
{
    . = BASE_ADDRESS;
    .text : {
        *(.text.entry)
        *(.text .text.*)
    }
    . = ALIGN(4K);
    .rodata : {
        *(.rodata .rodata.*)
        *(.srodata .srodata.*)
    }
    . = ALIGN(4K);
    .data : {
        *(.data .data.*)
        *(.sdata .sdata.*)
    }
    .bss : {
        *(.bss .bss.*)
        *(.sbss .sbss.*)
    }
    /DISCARD/ : {
        *(.eh_frame)
        *(.debug*)
    }
}
```

* **用户的可执行文件ELF不需要丢弃元信息**，在内核加载的时候会直接解析ELF文件将各个段放到指定的位置

### 3. 将用户镜像打包在磁盘文件中

所有用户ELF文件都会预先在[[6. 文件系统生成和使用|文件系统的生成]]时处理并加载到文件系统中，构建出一个完整的文件系统（包括 `DiskInode` 等）

## 2. PCB和TCB

### 1. PCB

`PCB` 中包含了整个进程的内核和用户空间，多个线程用的都是同一个 `MemorySet`（包括页表）

```rust
// os/src/task/process.rs
pub struct ProcessControlBlock {
    // immutable
    pub pid: PidHandle,
    // mutable
    inner: UPSafeCell<ProcessControlBlockInner>,
}

pub struct ProcessControlBlockInner {
    pub is_zombie: bool,
    // 整个内存空间（内核&用户）
    pub memory_set: MemorySet,
    pub parent: Option<Weak<ProcessControlBlock>>,
    pub children: Vec<Arc<ProcessControlBlock>>,
    pub exit_code: i32,
    pub fd_table: Vec<Option<FileDescriptor>>,
    pub signals: SignalFlags,
    // 所有线程
    pub tasks: Vec<Option<Arc<TaskControlBlock>>>,
    // 资源分配器，用来分配tid
    pub task_res_allocator: RecycleAllocator,
    pub mutex_list: Vec<Option<Arc<dyn Mutex>>>,
    pub semaphore_list: Vec<Option<Arc<Semaphore>>>,
    pub condvar_list: Vec<Option<Arc<Condvar>>>,
    pub work_dir: Arc<FileDescriptor>,
}
```

### 2. TCB

`TCB` 是实际上执行任务的单位，每个 `TCB` 都有自己的用户栈、`TrapContext`、内核栈

```rust
// os/src/task/tasks.rs
pub struct TaskControlBlock {
    // immutable
    pub process: Weak<ProcessControlBlock>,
    // 内核栈id
    pub kstack: KernelStack,
    // mutable
    inner: UPSafeCell<TaskControlBlockInner>,
}

pub struct TaskControlBlockInner {
	// 用户栈资源
    pub res: Option<TaskUserRes>,
    // TrapContext的物理页号，供内核直接找到
    pub trap_cx_ppn: PhysPageNum,
    // 内核上下文TaskContext
    pub task_cx: TaskContext,
    pub task_status: TaskStatus,
    pub exit_code: Option<i32>,
}


// os/src/task/id.rs
pub struct TaskUserRes {
    pub tid: usize,
    pub ustack_top: usize,              // user stack top
    pub ustack_bottom: usize,          // user stack bottom
    // manager all the stacks(thread0 may have many stack frame, but other thread has one)
    // the element is (stack frame top, bottom)
    pub ustack_frames: Vec<(usize, usize)>, 
    pub process: Weak<ProcessControlBlock>,
}
```

## 3. 初始进程initproc创建用户进程

用户态下第一个进程就是 `initproc` 进程

### 1. initproc的执行

* 他首先负责创建 `user_shell` 进程来监听用户输入，执行各种命令对应的进程是由 `user_shell` 负责的
* 然后循环监听所有可以释放了的进程

```rust
// user/src/bin/initproc.rs
fn main() -> i32 {
    if fork() == 0 {
        exec("user_shell\0");
    } else {
        loop {
            let mut exit_code: i32 = 0;
            let pid = wait(&mut exit_code);
            if pid == -1 {
                yield_();
                continue;
            }
            println!(
                "[initproc] Released a zombie process, pid={}, exit_code={}",
                pid,
                exit_code,
            );
        }
    }
    0
}
```

### 2. user_shell 的创建和执行

#### 1. fork

具体过程：

1. 拷贝 `MemorySet` 内存空间，包括物理页帧分配和页表映射（这里包括了所有页表和物理页帧的重新分配，包括`Trampoline` 的映射，用户的 `sections`、用户栈、`TrapContext` 以及 进程堆、mmap空间）
	* 如果是COW就将可写区域作为COW部分只进行页表映射
2. 创建 `PCB` 和主线程 `TCB`
3. 分配新的内核栈给 `TCB`

#### 2. exec

与创建一个新的进程类似（但是可以复用内核栈、用户栈、TrapContext等已经分配过的东西，只不过需要稍加修改）：

1. 从磁盘中读取ELF文件创建 `MemorySet` 内存空间（包括 `sections`）
2. 修改 `TrapContext`
3. 将函数参数放到 `user_stack` 中

### 3. 执行对应的用户程序

其他应用程序是通过在 `user_shell` 中输入应用名称，之后在文件系统中查找并加载到物理内存中来执行的（这里确保只有当前进程只有一个线程的时候才能 `fork`），加载方式也是 `fork & exec`

## 3. 从内核返回用户态

### 1. 切换线程

* 第一次切换线程回到用户态是**内核主线程调用** `run_tasks()` 从 `TaskManager` 中的 `ready_queue` 中选择一个线程来执行
* 之后是通过时钟中断/用户手动切换调用 `schedule()` 来保存当前上下文信息到 `TCB` 的 `TaskContext` 中，然后**切换回内核主线程**继续 `run_tasks()`

### 2. 返回用户空间

* 用户对应的内核线程**被第一次切换**：其 `TCB` 中的 `TaskContext` 中的 `ra` 初始时被设置为返回到 `trap_return()` 方法中执行，之后会跳转到 `__restore` 中返回用户空间
* **之后的切换**：其 `TCB` 中的 `TaskContext` 中的 `ra` 为返回到之前执行 `schedule()` 中的调用 `__switch` 之后的代码继续执行