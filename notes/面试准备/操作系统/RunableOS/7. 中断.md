# 一、时钟中断

内核初始化的时候**开启时钟中断**（S态下的中断），设置 `sie` 寄存器开启时钟中断（ `sstatus` 的 `SIE=0, SPIE=0`）：

1. 这样在 `sret` 返回到用户态的时候 `sstatus.SIE=0, SPIE=0`，但是由于S态权限高于U态，所以不会屏蔽用户态下的内核态的时钟中断
2. 在进入内核态时由于 `sstatus.SIE=0, SPIE=0`，所以会屏蔽内核态下所有内核态的中断，包括内核态的时钟中断

# 二、内核态下的中断

内核态下**会屏蔽内核态的中断**，如果出现了机器态的中断直接就直接 `panic`

* 内核态初始化时 `sstatus.SIE=0, SPIE=0`，所以无论怎样内核态都不会接收内核态的中断
* 在中断进入内核态时，会设置 `stvec` 的入口为函数 `trap_from_kernel()`，里面会直接 `panic!()`

```rust
// os/src/trap/mod.rs
fn set_kernel_trap_entry() {
    unsafe {
        stvec::write(trap_from_kernel as usize, TrapMode::Direct);
    }
}

pub fn trap_handler() -> ! {
    set_kernel_trap_entry();
    // ...
}

pub fn trap_from_kernel() -> ! {
    use riscv::register::sepc;
    println!("stval = {:#x}, sepc = {:#x}", stval::read(), sepc::read());
    panic!("a trap {:?} from kernel!", scause::read().cause());
}
```

在配置好了外设的寄存器到内存，并且配置到PLIC后，当外设产生中断 -> 发送到PLIC中 -> PLIC发送到CPU执行 `ecall` 中断进入内核