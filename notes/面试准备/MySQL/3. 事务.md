# 一、事务简介

## 1. 事务特性：ACID

* 原子性
* 一致性
* 隔离性
* 持久性

## 2. 并发事务的问题

* 丢失修改：两个事务同时修改
* 脏读：回滚
* 不可重复读：前后读取结果不一致，其他事务修改
* 幻读：前后读取结果不一致，其他事务插入新值

## 3. 事务隔离级别

1. 读取未提交：允许读取未提交数据 -> 脏读、不可重复读、幻读
2. 读取提交：允许读取提交 -> 不可重复读、幻读（事务1修改/更新）
3. 可重复读（MySQL默认）：同一事务前后读取一致 -> 幻读
	* MySQL使用这个结合**快照读**和**当前读**来解决幻读问题
		* 快照读：利用MVCC机制来读取，可以读取历史快照信息
		* 当前读：利用锁机制来读取，读的时候不允许写，写的时候也不允许读
4. 可串行化：解决全部问题

# 二、MVCC 多版本并发控制

## 1. Read View

`Read View` 可以看成是一个快照，通过 `Read View` 可以实现 读取提交和可重复读：

1. 读取提交：每次读取的时候重新创建 `Read View`（读取提交了的信息）
2. 可重复读：事务开始的时候创建 `Read View`（读取当前事务开始时的信息）

### 1. 字段

* `creator_trx_id`：当前事务的id
* `m_ids`：创建当前 `Read View` 时数据库中活跃且未提交的事务id列表
* `min_trx_id`：最小的活跃且未提交的事务id
* `max_trx_id`：数据库应该给下一个事务的id（不一定等于当前事务id+1，可能更后面的事物先提交导致其值更大）

![[Pasted image 20240322091019.png]]

### 2. 行/记录的隐藏列

* `trx_id`：当前记录被哪一个事务进行改动
* `roll_ptr`：每次改动数据时都会将之前的记录存放到 `undo` 日志中，并且用 `roll_ptr` 执行undo日志（存储了旧版本记录）
	* 当所有事物的 `min_trx_id` 都小于日志中的记录 `trx_id` 时该记录之前的记录就能够删除

![[Pasted image 20240322091239.png]]

### 3. 事务访问记录的规则

1. 当前记录的 `trx_id` 小于事务的 `Read View` 中的 `min_trx_id`，表示当前记录在创建 `Read View` 前**已提交**，所以当前记录对当前事务**可见**
2. 当前记录的 `trx_id` 大于等于事务 `Read View` 中的 `max_trx_id`，表示当前记录是**新事务修改**的，该版本的记录对当前事务**不可见**
3. 当前记录的 `trx_id` 在事务的 `Read View` 的 `[min_trx_id, max_trx_id)` 之间：
	1. 如果 `trx_id` 在已启动但未提交的事务 `m_ids` 中，**不可见**
	2. 否则表示当前版本记录的事务已提交，**可见**
4. 对于不可见的当前记录，需要通过记录的 `undo` 列表找到旧版本记录来继续查询

![[Pasted image 20240322091537.png]]

## 2. 可重复读

* 在**启动事务时**创建 `Read View`，这样整个事务阶段读的都是事务开启前的快照，即使有提交的事务修改了值，当前事务的 `m_ids` 还是不变，依旧不可读提交事务的记录

如下图右边事务A修改了记录值，事务B读取的是旧版本 50 的记录；**即使事务A提交了，事务B的 `Read View` 依旧不变**，读取的依然是旧版本的 50 记录

![[Pasted image 20240322092717.png|310]]![[Pasted image 20240322092751.png|310]]

## 3. 读提交

* **每次读取的时候创建**新的 `Read View`，这样就能够将所有已提交的事务从 `m_ids` 和 `max_trx_id` 中移除，所以就可以访问对应版本记录

下图中事务A提交了，事务B再读的时候会**更新 `Read View`，所以能够读取事务A提交的记录**

![[Pasted image 20240322093223.png]]

# 三、幻读

幻读就是事务内部前后读取的结果不一样

* **快照读**：普通 `select` 查询语句，查询的是快照数据
* **当前读**：除了普通查询外都是当前读，包括 `update, delete, insert, select ... for update`，查询的是最新数据

## 1. 快照读解决幻读

快照读采用的是**MVCC**来解决幻读，可重复读下的 `Read View` 可以避免查询到新增的数据

## 2. 当前读解决幻读

当前读由于要读取最新数据，所以是会通过添加`next-key lock`（包括记录所和间隙锁）方式来避免其他事务修改/新增/删除

例如下面事务A添加了间隙锁 $(2,+\infty)$，所以事务B插入id=5就会被阻塞

![[Pasted image 20240322100019.png]]

## 3. 幻读无法解决的场景

### 1. 快照读

如果事务B插入了一条记录并提交，然后事务A更新了该记录（更新操作查找最新），这样事务A前后两次查询结果不一致

![[Pasted image 20240322100136.png]]

### 2. 当前读

如果事务A**先进行快照读查询**，然后事务B插入数据并提交，事务A**再进行当前读**，由于前面快照都没有加锁，导致事务B可以插入数据，并且最后的当前读会读取最新数据，所以前后查询结果不一致

