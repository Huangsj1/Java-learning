# 一、B+树

MySQL底层数据结构是通过B+树来实现的

1. **哈希表**不方便排序、区间查询
2. **AVL树**需要多次旋转访问磁盘，且层数较高
3. **红黑树**也需要额外操作且不够平衡、层数过高查询访问磁盘过多
4. **B树**所有节点存储数据，每个节点占用空间多，相同磁盘IO下能查询的节点较少；且范围查询的时候需要进行中序遍历访问更多节点
5. **B+树**叶子节点存储数据，**层数较少，查找时访问节点少IO较少**；且叶子节点通过**双向链表连接，适合范围查询**，而且也适合叶子节点数据存储所以用的是B+树；而且有**大量冗余节点，插入删除效率较高**

* 老版的MyISAM引擎B+树叶子节点数据是**实际数据的地址**，属于**非聚簇索引**
* 新版的InnoDB引擎B+树叶子节点的数据是**实际数据**，属于**聚簇索引**（主索引才是聚簇索引，其他不是）

# 二、索引

索引：用于**快速查找**记录的一种**数据结构**

* **主键索引**：
	1. 如果有主键默认选择主键作为聚簇索引的索引键
	2. 否则选择非NULL且唯一的列作为索引键
	3. 否则自动生成隐式自增id列作为索引键
* **二级索引**：除了主索引外的其他**辅助索引**，叶子节点存储的是数据的**主键值**，查找时先根据辅助索引找到对应的键值，再根据主索引查找（回表），属于**非聚簇索引**
	* 二级索引不一定需要两次查询，如果查询的字段正好在索引中，那么一次查询即可在叶子节点中获得字段
* **覆盖索引**：索引包含所需要查询的字段的值，那么只用查询一次即可
* **联合索引**：使用表中的多个字段来创建索引，每个节点都存储了联合索引所有字段作为索引，叶子节点数据为主键值

## 1. 联合索引

对于一张下图所示的表：

![[Pasted image 20240315111018.png|300]]

主键id默认创建索引，如果我们直接执行查询语句，由于字段 `merchant_id` 和 `order_id` 都**没有创建索引**，所以会**遍历全表进行查询**

```sql
SELECT * FROM test_table_union_index WHERE merchant_id = 3 AND order_id = 2;
```

如果创建了联合索引，最会通过**最左前缀原则进行索引创建**，包括 `(merchant_id), (merchant_id, order_id)`

* 联合索引的非叶子节点中存储的是**索引中的所有列**（所以在查询的时候当索引中前面列相同时，可以用后面的列来进行索引查找）
* 非叶子节点中存储的是**主键 + 联合索引所有列**

```sql
CREATE INDEX idx_merchantid_orderid ON tb(merchant_id, order_id);
```

组合索引**属性从左到右依次有序**，如下图所示，首先根据`merchant_id`进行排序，在 `merchant_id` 相同的情况下根据 `order_id` 排序

![[Pasted image 20240315112109.png]]

这时再执行上面查询语句的时候会先找到 `merchant_id=3`的所有叶子节点，然后再在这些叶子节点中找到 `order_id=2` 的叶子节点（两次都是有序的）

![[Pasted image 20240315112716.png]]

* 注意：联合索引只有当查询/排序条件中**包含联合索引最左匹配原则**时才会使用（例如创建联合索引 (a, b, c)，当条件中有 `where a=***, b=***`时会使用，但是 `where b=***` 不会使用，且多个条件时编译器会做优化调换顺序）

### 范围查询

但是如果执行了范围查询，在联合索引中进行范围查询的属性之后的属性都不会进行索引查找，而是**遍历**（但是如果**范围包括边界，对于边界值还是会用索引查找，其他值遍历**）

因为索引的有序是**从左到右依次局部有序**（最左边属性是全局有序），对于当前属性如果进行范围查询，会得到其多个范围的叶子节点，每个范围内下一个属性是有序的，但是这些范围之间下一个属性是无序的，所以要遍历这些范围内所有叶子节点

## 2. 索引创建时机

* 适合创建索引：
	1. 字段唯一
	2. 经常用 `where`、`group by`字段查询
* 不适合创建索引：
	1. 字段中存在大量重复数据，这种情况下创建和维护索引消耗资源大，而查询只能快一倍，还不如全表扫描
	2. 数据较少
	3. 经常更新的字段

## 3. 索引失效

1. 使用 左 / 左右 模糊匹配（`like %xx` 或 `like %xx%`）
2. 对索引使用函数/表达式计算
	* 使用函数后的值没有了索引，如 `length(name)`
	* 将表达式当作一整块来查询，不进行优化，如 `id+1=10` 不会优化成 `id=9`
3. 联合索引不遵循最左匹配原则
4. 使用 `OR` 前的条件是索引列，`OR`后的条件不是索引列（因为只要满足其中一个条件即可，如果前面走索引，后面还需要全表扫描一次，所以索性就全表扫描一次）

## 4. 扫描二级索引

如果**有索引覆盖了当前需要查找的字段**，那么**查找的时候采用的就是扫描二级索引，而不是全表扫描**，因为二级索引叶子节点包含了需要查找的所有字段，虽然全表扫描也可以，但是聚簇索引的叶子节点中包含了很多多余信息（事务id、MVCC回滚指针等）

例如：表中只有两个字段，主键id和普通索引name，如果执行查询语句 `select * from tb where name like "%xx"`，因为所有字段只包括 id 和 name，它们都存储在二级索引name的叶子节点中，所以采用的是**扫描二级索引**

# 三、InnoDB数据存储

## 1. 存储结构

* InnoDB是按页进行磁盘读取的，称为“**数据页**”，每一页中包含了多行数据
* **页之间通过双向链表连接**，实现了逻辑上的连续
* 每个数据页里面的**行通过单向链表连接**
* 为了加快页内行记录的查询速度**对行进行了分组**，通过**页目录中的槽可以得到每一组的最大记录**（组内索引最大值），这样查询的时候就可以通过对页目录中的**槽进行二分查找**，快速定位索引所在位置
* InnoDB的**每一个节点都是一页**（可能一页存不下一行数据，需要多页来作为一个节点），非叶子节点数据为下一页的磁盘地址，叶子节点中的数据为行数据

![[Pasted image 20240321155508.png]]

![[Pasted image 20240321160018.png]]
![[Pasted image 20240321155640.png]]

## 2. 单表不超过2000W行

如果主键是int类型，那么单表最大可存储 $2^{32}-1$（21亿）行数据；但是如果**数据行数超过了2000W值左右，会导致树的层数变高导致查询效率降低**

* 非叶子节点指向其他页数量为 x
	* 每个节点为一页16KB大小，除去1KB左右的头部、页目录等信息，剩下15KB用来存储索引；每个索引包括主键+页号（8+4=12字节），则 $x=\frac{15*1024}{12}=1280$ 
* 叶子节点最多容纳行数为 y
	* 假设一条数据1KB，则 $y=\frac{15*1024}{1024}=15$ 
* B+树层数为 z
	* 假设B+树三层，则 $z=3$
* 则 $总行数 = x^{z-1}*y = 1280^{3-1}*15 = 2.45kW$ 即2000W行左右（每行数据越大，建议数据行数越少，否则容易增加B+树层数）

# 杂项

## 1. count()

`count()` 是用来查询**指定参数不为NULL**的字段有多少个，通过**遍历所有数据**（二级索引 / 主键索引）来增加变量 `count` 的值来得到结果

效率：`count(*) = count(1) > count(主键字段) > count(普通字段)`

* `count(主键字段)`：数据库查询每条记录的时候会返回数据，然后在 `Server` 中判断数据是否为空来技术
* `count(1)`：表中 `1 != NULL` 的数据有多少个，**查询时不会返回数据，只返回记录**，所以比 `count(主键字段)` 更快
* `count(*)`：相当于 `count(1)`
* `count(普通字段)`：全表扫描

前三个如果有二级索引就采用**二级索引**，否则采用主键索引进行全表扫描；最后一个直接**全表扫描**

* MyISAM存储引擎中会对每张数据表维护一个变量 `row_count` 记录数据数量
* InnoDB没有维护表数据数量的变量，因为存在MVCC，无法用一个变量维护当前表数据数量

### 优化 count(\*)

1. 近似值：在 `select count(*)` 前加上 `explain` 来模拟执行获取大概数量
2. 额外的表记录：每次增删的时候在额外的表中维护数量值

