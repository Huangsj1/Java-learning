# 一、B+树

MySQL底层数据结构是通过B+树来实现的

1. **哈希表**不方便排序、区间查询
2. **AVL树**需要多次旋转访问磁盘
3. **红黑树**也需要额外操作且不够平衡、层数过高查询访问磁盘过多
4. **B树**所有节点存储数据，范围查询的时候需要进行中序遍历访问更多节点
5. **B+树**叶子节点存储数据，**层数较少**，查找时访问节点少IO较少；且叶子节点通过**双向链表连接，适合范围查询**，而且也适合叶子节点数据存储所以用的是B+树

* 老版的MyISAM引擎B+树叶子节点数据是**实际数据的地址**，属于**非聚簇索引**
* 新版的InnoDB引擎B+树叶子节点的数据是**实际数据**，属于**聚簇索引**（主索引才是聚簇索引，其他不是）

# 二、索引

索引：用于**快速查找**记录的一种**数据结构**

* **二级索引**：除了主索引外的其他**辅助索引**，叶子节点存储的是数据的**主键+索引值**，查找时先根据辅助索引找到对应的键值，再根据主索引查找，属于非聚簇索引
	* 二级索引不一定需要两次查询，如果查询的字段正好在索引中，那么一次查询即可在叶子节点中获得字段
* **覆盖索引**：索引包含所需要查询的字段的值，那么只用查询一次即可
* **联合索引**：使用表中的多个字段来创建索引

## 联合索引

对于一张下图所示的表：

![[Pasted image 20240315111018.png|300]]

主键id默认创建索引，如果我们直接执行查询语句，由于字段 `merchant_id` 和 `order_id` 都**没有创建索引**，所以会**遍历全表进行查询**

```sql
SELECT * FROM test_table_union_index WHERE merchant_id = 3 AND order_id = 2;
```

如果创建了联合索引，最会通过**最左前缀原则进行索引创建**，包括 `(merchant_id), (merchant_id, order_id)`

```sql
CREATE INDEX idx_merchantid_orderid ON tb(merchant_id, order_id);
```

组合索引**属性从左到右依次有序**，如下图所示，首先根据`merchant_id`进行排序，在 `merchant_id` 相同的情况下根据 `order_id` 排序

![[Pasted image 20240315112109.png]]

这时再执行上面查询语句的时候会先找到 `merchant_id=3`的所有叶子节点，然后再在这些叶子节点中找到 `order_id=2` 的叶子节点（两次都是有序的）

![[Pasted image 20240315112716.png]]

* 注意：联合索引只有当查询/排序条件中**包含联合索引最左匹配原则**时才会使用（例如创建联合索引 (a, b, c)，当条件中有 `where a=***, b=***`时会使用，但是 `where b=***` 不会使用，且多个条件时编译器会做优化调换顺序）

### 范围查询

但是如果执行了范围查询，在联合索引中进行范围查询的属性之后的属性都不会进行索引查找，而是**遍历**

因为索引的有序是**从左到右依次局部有序**（最左边属性是全局有序），对于当前属性如果进行范围查询，会得到其多个范围的叶子节点，每个范围内下一个属性是有序的，但是这些范围之间下一个属性是无序的，所以要遍历这些范围内所有叶子节点