# 一、Buffer Pool

`MySQL` 在内存中拥有一个 `Buffer Pool` 缓冲池，里面记录了数据页、索引页、undo页等数据

当这些页面被修改的时候就会被记录为脏页，默认在以下情况会写回磁盘：

1. 系统内存不足在换页的时候会写回
2. MySQL正常关闭的时候
3. MySQL认为系统正常时
4. InnoDB的 `redo log` 写满

![[Pasted image 20240322113816.png]]

## 1. Buffer Pool的管理

* `Free` 链表：管理空闲页面
* `Flush` 链表：管理脏页
* `LRU` 链表：管理脏页和干净页

![[Pasted image 20240322155311.png]]![[Pasted image 20240322155330.png]]![[Pasted image 20240322155354.png]]

![[Pasted image 20240322155457.png]]

## 2. LRU链表的优化

### 1. 解决预读失效

* 预读机制：MySQL加载页时，会**将相邻的页一起加载**
* 预读失效：加载的相邻的页没被访问

解决办法：将LRU链表分成 `young` 和 `old` 区，`young`区存放的是真正要读写的，`old`区存放的是预读的，只有当预读的区被访问时采访到 `young` 区开头

![[Pasted image 20240322155944.png]]![[Pasted image 20240322155951.png]]

### 2. 解决 Buffer Pool 污染

当SQL语句**扫描了大量数据**时，会将 `Buffer Pool` 中的数据都替换出去，**导致热点数据大量淘汰**，而新加入的数据可能只访问一次（例如查询语句发生索引失效需要全表扫描，读取每一条记录来检查where条件是否成立）

解决办法：由于这些大量扫描数据只会在短时间内访问一次，所以让其从 `old` 区进入 `young` 区时添加条件：只有**当其后续访问时间与第一次载入时间超过一定时间间隔（1s）后被访问才会加载到 `young` 区**（也就是要在 `old`区停留超过1s并被访问才放入 `young`区）

# 二、日志文件

## 1. undo log 回滚日志

对于“增删改”操作，数据库默认会隐式开启事务来执行，执行完后就自动提交更新到数据库中。在一个事务执行过程中，如果执行了多条更新语句，他们都被写到了数据库中，但是在事务提交之前**事务崩溃**了，**之前的操作都需要撤回**，所以就有了 `undo log` 来记录之前的操作

撤销操作：

1. 插入操作：删除记录的主键
2. 删除操作：需要先记录日志内容，回滚后再重新插入
3. 修改操作：记录旧值，回滚后更新为旧值

![[Pasted image 20240322113341.png|200]]

`undo log` 作用：

1. 实现事务**回滚**，保障**原子性**
2. 实现MVCC

## 2. redo log 重做日志

由于数据库的各种操作都先在 `Buffer Pool` 内存页面中进行操作，如果**数据库崩溃了，里面的操作和新数据就丢失了**，所以需要通过 `redo log` **记录内存中页面的变化**（比如对xxx表空间xxx页xxx偏移量做了xxx修改），然后快速写到磁盘中，这样即使内存数据丢失，也能够根据 `redo log` 恢复出原来内存的模样

![[Pasted image 20240322114723.png]]

`redo log` 作用：

1. 实现事务的**持久化**，让MySQL有 `crash-safe` 能力
2. 将写操作从数据的**随机写**转换成**顺序写**（顺序写入磁盘文件中），提高写磁盘效率

### 1. 写回磁盘时机

1. MySQL正常关闭
2. `redo log buffer` 中记录写入量占可用空间一半以上
3. InnoDB后台线程**每隔1s写入**
4. **事务提交**时会写入（通过设置参数 `innodb_flush_log_at_trx_commit` 可以采取不同策略写回）

![[Pasted image 20240322144344.png]]![[Pasted image 20240322144540.png]]

### 2. 文件满了清除

两个日志文件**循环写**：`write pos`为当前写的位置/队尾，`check point`为需要擦除的开始位置/队头，当 `write pos` 到达 `check point` 时表示日志文件满了，需要**阻塞MySQL的更新**，停下来**将脏页写入到磁盘中**，然后标记哪些记录可以被擦除，**擦除后 `check point` 可以继续往后走**

![[Pasted image 20240322144746.png|320]]![[Pasted image 20240322144755.png|310]]

## 3. binlog 归档日志

`binlog` 的主要用于**文件数据恢复**和**主从复制**

MySQL每执行一条更新操作都会在 `binlog cache`（类似 `buffer`） 中生成一条记录，事务提交后再统一写入 `binlog` 文件中

![[Pasted image 20240322150008.png]]

`binlog` 和 `redo log` 区别：

1. `binlog` 是MySQL的server层实现，适用于所有存储引擎；`redo log` 是InnoDB存储引擎实现的 
2. `binlog` 记录了所有的SQL语句；`redo log`记录的是内存物理页的修改情况
3. `binlog` 追加到文件中，满了就继续创建文件追加；`redo log`是循环添加
4. `binlog` 用于备份恢复、主从复制；`redo log`用于故障恢复

### 主从复制

![[Pasted image 20240322145544.png]]

# 三、两阶段提交

## 1. 提交过程

由于 `redo log` 和 `binlog` **都需要写入到磁盘**中，但是二者是互相独立的，如果只完成其中一个都会出问题（前者用于恢复主数据库的故障，后者用户从数据库的数据同步，只完成其中一个会导致主从数据库不一致）

MySQL开启内部 XA 事务，分两阶段完成提交过程：

1. `prepare` 阶段：将 XID（XA事务的id）写入到 `redo log` 中，同时设置 `redo log` 事务状态为 `prepare`，然后将 `redo log` 持久化到磁盘中
2. `commit` 阶段：将 XID 写入到 `binlog` 中，然后将 `binlog` 持久化到磁盘中；之后调用引擎的事务接口将 `redo log` 状态设置为 `commit`，这里只需要写到页面缓冲区 `page cache` 即可，不用写入磁盘

![[Pasted image 20240322151935.png]]

## 2. 异常重启

异常处理过程：

1. MySQL重启时会先扫描 `redo log` 文件，**找到处于 `prepare` 阶段的记录**，然后根据其 `XID` 去 `binlog` 文件中找是否存在
	1. 如果存在代表 `redo log` 和 `binlog` 都完成刷盘，重新提交事务（时刻B）
	2. 不存在表示 `binlog` 未完成刷盘，回滚事务（时刻A）

![[Pasted image 20240322152852.png]]

## 3. 存在的问题

1. 磁盘IO次数高：每次事务提交都要两次刷盘
	* 可以通过组提交方式，多个 `binlog` 刷盘操作合并成一个一起执行
2. 锁竞争激烈：多事务情况下需要加锁保证两阶段的原子性

# 四、事务执行过程

执行一条更新操作的流程（假设已经读取缓存、解析、优化过了，到InnoDB中进行更新）：

1. 开启事务，将记录旧值保存到 `undo log` 中（即 `undo buffer`），由于修改了undo buffer的页面，所以需要记录对应的内存修改到 `redo log` 中（`redo buffer`）
2. 更新记录值，由于修改了数据内存，所以需要标记内存的脏位，且写入 `redo log`中
3. 更新完成后，将该sql语句记录到 `binlog` 中（即 `binlog cache`）
4. 事务提交进入两阶段提交：
	1. `prepare` 阶段：将XID和 `prepare` 写入 `redo log` 中并刷盘
	2. `commit` 阶段：将XID写入 `binlog` 中并刷盘，将 `commit` 写入 `redo log`中
