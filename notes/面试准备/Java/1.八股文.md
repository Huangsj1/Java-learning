# 一、Java

jdk 包含 jre 包含 jvm 包含 jit

---

* `==` 可用于判断基本数据类型是否相等
* `equals()` 用于判断引用类型是否相等（对于4种整型包装类型会有部分缓存值，它们地址相同所以可以用 `==` 判断）
	* 这是 `Object` 对象中的方法，默认是比较内存地址是否相同，一般需要重写（String的被重写来判断字符串是否相等了）

---

* `String` 对象里面有一个字符串数组 `private final char[] value;`：`private` 说明外界无法直接访问，String类里面没有 `getValue()` 方法说明外界也无法直接获得访问，`final` 说明value不能指向别的字符数组，但是**可以修改value所指向的字符数组中的字符**（需要通过反射获取value然后修改数组中的元素）
	* 但是 `String s1 = "abc"` **直接引用的是字符串常量池的字符串对象**，而不会在堆中创建 `String` 对象
	* `String s2 = new String("abc)` 才会创建对象，其 `value[]` 引用字符串常量池里面的字符串

```java
public class ScannerUse {  
    public static void main (String[] args) throws NoSuchFieldException, IllegalAccessException {  
        String s1 = "abc";  
        String s2 = "abc";  
        Field valueFieldOfString = String.class.getDeclaredField("value");  
        valueFieldOfString.setAccessible(true);  
        char[] value = (char[]) valueFieldOfString.get(s1);  
        value[1] = '_';  
        System.out.println(s1);  
        System.out.println(s2);  
    }  
}
// 运行结果是：
// a_c
// a_c
// 说明可以通过反射修改String对象中字符数组的内容，即字符串常量池中的字符串
```

---

* **局部变量**没有默认初始化值，**不初始化在使用时会报错**
	1. 如果帮助我们初始化，但是有些局部变量可能存在可能不存在，且可能会重复/覆盖声明，这样不断帮我们初始化会带来**性能问题**
	2. 本来不初始化就有问题，且赋值取值顺序确定，**编译器可以帮助检查**
* **成员变量**有默认初始化值，由**构造方法赋值**
	1. 有些变量可能在**运行时才动态赋值**，所以编译时不能报错
	2. 对象创建的时候只要将**变量区域全部赋值0**就好了，简单高效

---

静态方法只能调用静态方法和类的静态成员，不能调用非静态方法和访问非静态成员

---

继承：子类**拥有**父类的私有属性，但是**无法访问**

---

多态：内存中的方法区会存储每个类的class对象，里面保存了方法、类变量、成员变量、方法表以及一个指针，该指针指向该类的方法表（包括Object类、父类、子类的方法），如果**重写了父类的方法就会覆盖方法表中父类的方法**来实现多态（由于继承是单一的，所以采用的是固定偏移；但接口可以实现多个，需要进行搜索，所以性能更差一点）

---

* 接口的成员变量必须是 `public static final`：接口不能直接创建对象，需要被实现，所以是public、static；由于接口可能被多个类实现，所以静态变量不能改变（一个类中改变会影响到其他类使用该接口），所以是final
* 接口的方法可以是 `default`，因为如果需要对接口新增方法，就需要对所有实现类都添加该方法的实现，所以增加了 `default` 修饰的方法（有方法体），不需要实现该方法的类可以不实现

---

- 接口多实现；类单继承
- 接口的方法是 public abstract 修饰，变量是 public static final 修饰； 抽象类可以用其他修饰符
- 接口更像是扩展的插件，需要添加的方法；抽象类是某类事物的特征，是需要实现的
- 接口和抽象类的方法除了 `default` 和 `static` 外都需要子类去实现

---

* `equals` 是用来判断两个对象是否相等的
* `hashCode` 是得到对象对应的hash编码，不同对象可能有相同的编码，其计算/判断过程较为快速（`HashSet`中先判断hashCode，存在了再判断是否equals来判断是否有重复对象）

---

* **堆**用于存储**对象**和**数组**
* **栈**用于存储**局部变量**和**方法调用的信息**
* **方法区**用于存储**类相关信息**

---

* **字符串常量池**：
	* jdk7之前在永久代（包含了类信息、字符串常量池、运行时常量池、静态变量、JIT代码缓存）
		* 常量池是java代码编译后的 `.class` 文件中的常量部分，其运行时会被加载到运行时常量池
	* jdk7移出了永久代放到了堆中（堆中包含了字符串常量池、静态变量）
		* 静态变量存储在堆中的class对象里面
	* jdk8中移除了永久代（将剩余内容放到了元空间中），但方法区仍未改变，只是改变了物理位置
		* 元空间中包括：类的元数据（包括类的定义信息和字节码等）
	* ![[Pasted image 20240225210000.png]]

---

* JVM 其实并不能识别语法糖，Java 语法糖要想被正确执行，需要先通过编译器进行解糖（语法糖包括：泛型、自动拆装箱、变长参数、枚举、内部类、增强 for 循环等）
	* 虚拟机中没有泛型，只有普通类和普通方法，所有泛型类的类型参数在**编译时都会被擦除**，泛型类并没有自己独有的`Class`类对象
		* 两个重载的函数，他们的参数类型不同，一个是`List<String>`另一个是`List<Integer>` ，但是编译通不过，因为编译时会擦除泛型变为List得到相同参数
	* 使用`enum`来定义一个枚举类型的时候，编译器会自动帮我们创建一个`final`类型的类继承`Enum`类，所以枚举类型**不能被继承**
	* `outer`类里面定义了一个内部类`inner`，一旦编译成功，就会生成两个完全不同的`.class`文件了，分别是`outer.class`和`outer$inner.class`。所以内部类的名字完全可以和它的外部类名字相同

---

反射是通过获取类的Class对象后，根据该对象获取该类的元数据（父类、成员变量、方法等），同时还能修改成员变量/方法的访问权限来进行访问（会有安全问题）

---

* 静态代理：相当于创建一个新的类来注入被代理的类，然后在方法中通过调用被代理类的方法来实现代理（编译时就加载好字节码）
* 动态代理：通过定义新的类实现 `InvocationHandler` 接口，并重写 `invoke`方法，在该方法里面执行新增的操作和原本类的方法；之后通过`Proxy`类的方法来获取代理类对象来执行（运行时动态生成字节码）
	1. JDK动态代理：需要被代理类有接口
	2. CGLIB动态代理：不需要代理类有接口

---

* 浮点数的比较不要用等于（精度问题），而应该用一个小的范围
* `BigDecimal`是高精度小数，能够调用该类的方法进行加减乘除

---

* API：实现方提供的接口
* SPI：调用方提供的接口（本质通过反射得到所有实现类）

---

* `HashMap`中哈希值/数组下标的计算方法是“ `(n - 1) & hash`”，所以**数组长度n需要是2的次幂**（这样n-1之后&的大小才在 0~n-1）
* `HashMap` 中键和值可以是null，但是 `ConcurrentHashMap` 中不可以，因为多线程下如果获取了键/值为null，无法通过调用 `contain(key)` 来判断是否存在该键（因为如果在获取了键/值后，其他线程修改了该键），所以多线程下不能判断该null是键/值，还是不存在返回的null；而单线程在获取键/值后在调用 `contain(key)` 之前都不会被修改

---

* 1.7的 `ConcurrentHashMap` 采用的是对数组进行**分段加锁**，且数组中节点通过链表连接
* 1.8的 `ConcurrentHashMap` 将数组每个元素当作一个节点，是通过对**节点加锁**，节点中所有元素通过链表/红黑树连接

---

* `Arrays.asList()`是泛型方法，传递的数组必须是**对象数组**，而不是基本类型。如果是基本类型那得到的集合只有一个元素，即该数组对象
* 使用集合的修改方法: `add()`、`remove()`、`clear()`会抛出异常，因为`Arrays.asList()` 方法返回的并不是 `java.util.ArrayList` ，而是 `java.util.Arrays` 的一个内部类，这个内部类并没有实现集合的修改方法或者说并没有重写这些方法

---

* ArrayList 扩容：
	1. 计算数组所需最小容量（如果是默认初始化的数组最小容量为 `max(10, 初始最小容量)）
	2. 判断所需最小容量是否大于当前数组长度，大于则扩容
	3. 默认新容量为数组长度1.5倍，但如果依旧不够就用所需最小容量作为新容量，但如果该容量超出了数组最大长度（`Integer.MAX_VALUE-8`）就继续通过 `hugeCapacity()` 判断（如果最小所需容量大于数组最大长度就为整形最大值，否则为数组最大长度）

---

new 一个 `Thread`，线程进入了新建状态；调用 `start()`方法，会启动一个线程并使线程进入了就绪状态，当分配到时间片后就可以开始运行了。但是直接执行`run()` 方法，会把 `run()` 方法当成一个 main 线程下的普通方法去执行，并不会在某个线程中执行它，所以这并不是多线程工作

---

* JMM（Java内存模型）抽象了线程和主内存之间的关系：线程之间的共享变量必须存储在主内存中，每个线程都有各自的本地内存，在线程初始的时候会将主内存中的共享变量复制到本地内存中，修改读取都是在本地内存执行的，虽然本地内存中的变量能够同步到主内存中，但是不一定是实时的，所以可能导致**多线程下访问共享变量不一致**，出现**共享变量的不可见**
	* `volatile`关键字：
		1. 声明变量是共享变量，每次**读取都从主内存中读取最新值**，更改本地内存中结果都要**立刻同步到主内存**中，保证了**可见性**（但不保证原子性）
			* 具体实现：每次都让CPU缓存失效，从内存中读取
		2. 且**禁止指令重排序**（单线程下指令重排会保证执行结果一致；但是多线程下可能线程1重排后结果不变，但是线程1重排一半停止了，线程2执行的时候可能因为线程1执行了本应该在后面的代码而执行了其他代码，出现不一致）
			* 具体实现：通过内存屏障限制操作顺序
	* `synchronized` 和 `reentrantLock` 都可以保证可见性，因为JVM规定了进入同步块/获得锁后会强制撤销该线程工作内存中所有共享变量缓存，**读写直接在主内存中进行**

![[Pasted image 20240228201631.png|300]]

---

* 悲观锁：总是假设最坏情况，每次访问共享变量都需要加锁（写操作多）
	* `syschronized`、`reentrantLock`
* 乐观锁：总是假设最好情况，不加锁，只有在提交修改的时候才验证资源是否被其他线程修改（读操作多）
	* 版本号机制：通过在数据表中添加版本号 `version`表示数据修改次数，修改之前先读取，修改后提交时在读取检查版本是否一致，一致才修改
	* CAS 算法（Compare And Swap）：用V值和E值比较，相等才更新N=V
		1. ABA问题：开始读取的是A，然后被修改为B，又被修改为A，最后提交时读取的还是A，但是已经被修改过
		2. 循环开销大：自旋操作重试
* 公平锁 : 锁被释放之后，先申请的线程先得到锁
* 非公平锁：锁被释放之后，后申请的线程可能会先获取到锁，是随机或者按照其他优先级排序的
* 可重入锁/递归锁：线程可以重复获取自己的内部锁，例如已经获得对象的锁，可以再次获取该对象的锁
* 可中断锁：获取锁的过程中可以被中断，不需要一直等到获取锁之后才能进行其他逻辑处理（`ReentrantLock`）
- 不可中断锁：一旦线程申请了锁，就只能等到拿到锁以后才能进行其他的逻辑处理（`synchronized`）

---

- `synchronized` 关键字加到 `static` 静态方法和 `synchronized(class)` 代码块上都是是给 Class **类上锁**；
- `synchronized` 关键字加到实例方法和 `synchronized(对象)` 代码块上都是给**对象实例上锁**；
	- 其他线程也**不可以**访问该对象的**其他同步方法**
	- 但是其他线程**可以**访问该对象的**其他非同步方法**以及**该同步方法中用到的成员变量**
- `syschronized(this){}`是给当前**代码块上锁**（本质上this也是对象，也是获取该方法的对象的锁）
	- 编译生成的字节码文件会在代码块前加上 `monitorenter`，后面加上两次 `monitorexit`（一次正常退出，一次用来异常退出）；每个对象都内置一个 `ObjectMonitor` 对象，`monitorenter`会获取锁也就是对象监视器 `monitor` 的持有权（锁计数器从0变1），`monitorexit`释放锁（锁计数器从1变0）
	- 但是`syschronized`加到方法上不会添加上面两种关键字，而是添加`ACC_SYNCHRONIZED` 标识来指明该方法是同步方法，让JVM获取对象/类的锁
- `syschronized` 是基于JVM实现的

---

* `ReentrantLock` 可重入可中断的互斥锁，需要手动加锁 `lock()` 解锁`unlock()`
* `ReentrantLock` 是基于API的（基于AQS）

---

创建的对象是在堆中的，可以被所有线程共享，通过`ThreadLocal`变量可以让访问其的所有线程都有各自的本地副本

1. 调用该变量的 `set()` 方法时，会获取当前线程的 `ThreadLocalMap` 属性来添加值
2. 调用 `get()` 方法时也会获取当前线程的 `ThreadLocalMap` 属性来获取值
3. **内存泄漏**：由于`ThreadLocalMap`中的每一个 `Entry` 中的**key是弱引用**（仅有弱引用指向的对象在发生gc就会被回收），所以当 `ThreadLocal` 没有被外部强引用的情况下，在垃圾回收的时候，key 会被清理掉，而 **value 不会被清理掉**，于是`ThreadLocalMap`就会出现key为null的Entry，value就一直保存在线程中不被清理掉出现内存泄漏（直到线程结束才释放value）。所以在使用完 `ThreadLocal` 的时候要主动调用 `remove()` 清除
	* 如果key用强引用，那外界释放`ThreadLocal`后，`ThreadLocalMap`依然还持有`ThreadLocal`的强引用，这就导致`ThreadLocal`不能被清除
4. **Hash算法**：每增加一个 `ThreadLocal` 就对内部的值`threadLocalHashCode` 增加固定值（斐波那契数），数组下标为 `threadLocalHashCode & (len-1)`，冲突就**线性往后找**直到找到非null的键值（如果是泄露的键值就启动探测式数据清理）

![[Pasted image 20240228100248.png|400]]

- 强引用：普通的引用，强引用指向的对象不会被回收；
- 软引用：仅有软引用指向的对象，只有发生gc且内存不足，才会被回收；
- 弱引用：仅有弱引用指向的对象，只要发生gc就会被回收；
- 虚引用：就和没有任何引用一样，在任何时候都可能被垃圾回收，可用于垃圾回收检测

---

* 线程池 `ThreadPoolExecutor` 类
* `FixedThreadPool` 固定核心线程池和最大线程池大小，等待队列长度为`Integer.MAX_VALUE`
* `SingleThreadExecutor` 只有一个线程的线程池，等待队列长度为`Integer.MAX_VALUE`
* `CachedThreadPool` 会根据需要创建新线程的线程池，`corePoolSize` 被设置为空（0），`maximumPoolSize`被设置为 `Integer.MAX.VALUE`，会无限创建线程
* `ScheduledThreadPool` 用来在给定的延迟后运行任务或者定期执行任务，保证每次出队的任务都是当前队列中执行时间最靠前的，等待队列满了就会扩充，永远不会阻塞

![[Pasted image 20240228104539.png]]

---

`Future` 类（泛型）主要用于**异步**，当执行一个耗时的操作时，可以将其交给子线程异步执行，然后主线程就可以继续执行别的事情，事情结束后再通过 `Future` 类**获取耗时任务的执行结果**（可以取消任务、查看是否取消任务、查看任务是否执行完成、获取任务执行结果）

---

AQS 就是一个抽象类，主要用来构建锁和同步器。其里面有变量 `int status` 来展示当前临界资源获取锁的数量/状态

* 如果被请求的**共享资源空闲**，则将当前请求资源的线程设置为有效的工作线程，并且将共享资源设置为锁定状态
* 如果被请求的**共享资源被占用**，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制，这个机制 AQS 是用 **CLH 队列锁** 实现的（双向队列），即将暂时获取不到锁的线程加入到队列中。
	* ![[Pasted image 20240228111248.png]]

---

`CountDownLatch` **允许 `count` 个线程阻塞在一个地方**，直至所有线程的任务都执行完毕。默认构造**AQS** 的 `state` 值为 `count`，当线程使用其 `countDown()` 方法时会以 CAS 的操作来减少 `state` 直至 `state` 为 0 ；当调用其 `await()` 方法的时候，如果 `state` 不为 0，那就证明任务还没有执行完毕，`await()` 方法就会一直阻塞，直到`count` 个线程调用了`countDown()`使 state 值被减为 0

---

![[Pasted image 20240228163116.png|400]]

---

* 对象**优先在Eden区分配**，分配不下就对Eden区进行Minor GC，并将原本Eden区的对象放到**Suvivor空间**中，若放不下就放到**老年代**去
* 大对象（字符串、数组）直接进入老年代，长期存活的对象也进入老年代
* **分代收集算法**：
	1. 新生代：标记-复制算法，因为每次收集都有大量对象死去，复制少
	2. 老年代：标记-清除 或 标记-整理算法，因为对象存活率较高，需要清除的较少

---

* `Cookie` 存放在**客户端**，一般用来保存用户信息
* `Session` 的主要作用就是通过**服务端**记录用户的状态（安全性更高）
	* `Session` 通过在服务器记录用户信息，并将用户的 `SessionID` 放到 `Cookie` 中返回给浏览器。如果没有 `Cookie`，可以将 `SessionID` 放在请求的 `url` 里面
* `token` 是由服务器根据用户信息和密钥生成的，会响应会给**客户端**保存，服务器不会保存，客户端每次请求都携带token，服务器如果解析token成功就代表用户已登录
	* `token` 由Header、用户信息、签名（根据前两个+密钥生成的）组成

---

WebSocket 是一种基于 TCP 连接的全双工通信协议（应用层），即客户端和服务器可以同时发送和接收数据。

---

流式编程的特点：

1. 简洁优雅
2. 处理大数据高效：流式编程中，数据不是一次性加载到内存中，而是以流的形式逐步处理，这使得它能够处理大规模的数据集，而不会耗尽内存
3. 可以使用函数式编程
4. 易于并行

# 二、数据库



---

* MySQL数据库的实现：
	1. 可以用MVCC多版本来暂时执行事务的操作，如果回滚了就不保留新版本
	2. 也可以通过Undo日志，当前事务中的操作先记录到undo日志中，提交了才执行，否则就删除不执行

---

# 三、Spring

Spring中的设计模式：

1. IoC控制反转
2. AOP代理设计模式
	* SpringAOP属于运行时增强
	* AspectJ属于编译时增强
3. 工厂设计模式：通过 `BeanFactory` 和 `ApplicationContext` 创建bean对象
4. 单例设计模式：很多对象只需要一个，如容器、线程池等，且bean对象默认也是单例的
5. 模板方法

---

* 自动装配：通过注解或一些简单的配置就能够在SpringBoot帮助下实现某些功能（没有的是时候通过手动配置xml文件来加载很复杂）
	1. 引入第三方依赖：直接引入starter即可（`starter`是一种命名约定，能够简化构建配置依赖）
		* 通过启动类注解 `@SpringBootApplication`中的注解 `@EnableAutoConfiguration`来启动自动装配，该注解用到了`AutoConfigurationImportSelector`**加载自动配置类**，它会**扫描符合条件的starter的jar包中的 `META-INF/spring.factories`获取自动配置类**，之后还会经过**筛选保留**一些配置类，然后就可以注入这些配置类中用到的bean对象了
			* `MeTA-INF/spring.factories` 中存放着该jar包所有可以被引用的配置类
	1. 依赖注入：自动注入bean对象
		1. `@Autowired`：由Spring提供，默认按照类型byType注入
		2. `@Resource`：由J2EE提供，默认按照名称byName方式注入

---

* `@Transactional` 注解只能保证**MySQL数据库的事务原子性**，对于**NoSQL数据库（如Redis）不生效**，即方法中的**Redis操作会立刻执行**，但MySQL的操作只有在方法成功时才执行，在方法失败时不会执行
	* 利用的是MySQL的事务机制

---

* `@Value()` 将配置文件属性注入到类的变量中
	* `@Value(${})` 可以自动从**配置文件**读取属性值
	* `@Value(#{})` 使用的是Spring Expression Language (SpEL)，能够获取**对象**的属性值
* `@ConfigurationProperties(prefix = "")` 将配置文件属性注入到类中

---

`Spring`、`SpringMVC`、`SpringBoot`的特点：

* Spring：
	1. 开源容器框架，接管web层、业务层、dao层等组件
	2. `IOC`：可以通过xml文件或者注解的方式创建bean对象
	3. `AOP`：可以通过注解的方式进行动态代理
	4. `Transactional`：注解的方式定义方法为事务
* SpringMVC：
	1. 轻量级Web框架，负责分发请求到对应的控制类中处理
	2. 拦截器
* SpringBoot：
	1. 简化Spring应用的**初始化构建和开发过程**，可以自动配置第三方库依赖，并且通过**自动装配**来加载第三方库的bean对象到IoC容器中

---

* 过滤器：
	1. 依赖于**Servlet容器**
	2. 执行通过**Servlet回调**
	3. 主要用于处理**全局**的事情：对**字符编码、跨域等问题**进行过滤
	4. 能拦截**所有HTTP请求**
* 拦截器：
	1. 依赖于**Spring**
	2. 执行通过**动态代理**
	3. 主要用于处理**业务逻辑**相关的事情：**权限控制、参数校验、日志打印**等问题
	4. 只能拦截**控制类相关**的请求，无法拦截静态资源访问

---

* `Servlet` 是用Java编写的服务器端的程序，用来处理Web请求 或 生成动态Web页面（SpringMVC基于其构建）

# 四、MyBatis

* `#{}` 在Mybatis中是sql参数占位符，Mybatis会将其**替换为 ?**，在sql执行前会用参数值替换
* `${}` 会直接**将参数值/字符串替换进去**
	* 可能引发SQL注入问题，如传参为 `' OR '1'='1`，会出现 `SELECT * FROM users WHERE name = '' OR '1'='1';`的情况

---

Dao接口就是Mapper接口，每个Mapper接口都有一个对应的xml映射文件，且每个方法都可以在xml文件中有唯一id，如果要重载接口中的方法，可以通过在xml语句中使用 `<if>` 等动态标签


# 五、高性能

CDN（Content Delivery Network）内容分发网络：将**静态资源**分发到多个不同的地方实现就近访问，源站需要**预热**将资源放到CDN节点中，如果节点没有资源需要**回源**获取资源

分发过程：

1. 浏览器发送域名请求
2. DNS服务器解析域名并向GLSB（全局负载均衡）发送请求
3. GLSB返回性能最好的CDN节点地址（可能是离客户端最近的）
4. 浏览器直接访问CDN节点地址获取静态资源

---

* 数据库**读写分离**：通过**主从复制**保证主数据库和从数据库的数据是一致的（从数据库通过二进制日志文件binlog来重复主数据库的操作）
	* 主从延迟：可以让需要获取最新数据的操作在主数据库中执行
* **分库分表**：MySQL一张表中数据量过大
	* 分库：将数据库中的数据分散到不同数据库中
		* 垂直分库：将单一数据库按照业务进行划分（用户库、商品库）
		* 水平分库：将表中的数据按一定规则拆分到不同数据库（各一半）
	* 分表：将表中的数据分散到不同表中
		* 垂直分表：将表按照业务拆分
		* 水平分表：对表元组拆分
	* 带来的问题：
		1. 多表连接在不同数据库难实现
		2. 事务操作在不同数据库无法根据已有数据库来实现
		3. 跨库聚合（group by）问题

---

# 六、操作系统

* `OSInode`属于操作系统层面（主要包含inode编号和文件偏移量），`inode` 是属于文件系统层面的，`DiskInode`在磁盘的inode块中存储，每个 `inode` 关联一个磁盘块中的 `DiskInode`，`DiskInode`中存储着数据在磁盘中位置、文件/目录类型，所以 `DiskInode` 可以表示文件/目录
	* **磁盘的数据块中可以存数据/目录项，目录项中包括里面的文件/子目录名字和对应的 `DiskInode` 编号/位置**，根据编号就可找到文件/子目录
* 创建文件系统的时候会创建根目录，读取文件系统是从超级块中读取，包括里面的inode；绝大多数操作都是从根节点开始的
* 硬链接：在目录下创建一个**新的目录项**，目录项中存储着这个**链接的名字和原 `inode` 编号**
	* 硬链接和原文件的地位是同等的，都引用同一个inode，所以删除原文件不影响硬链接（共享）
	* 硬链接**不能链接目录**原因：会**形成环路造成循环**，如a目录下有个硬链接x链接b目录，b目录下有个硬链接y链接a目录，这就形成了环路；当查看a目录下所有目录/文件时会无限循环（a->x->b->y->a....）；或者a目录下的硬链接x链接a目录，会出现a的子目录是自己
		* 虽然可以通过**记录遍历过的inode编号来避免环路**，但可能是考虑到**开销问题**以及硬链接的目的（共享文件）就没有采用
* 软链接：在目录下创建一个**新的目录项和新的 `inode`**，目录项中存储着这个**链接的名字和新的 `inode` 编号**；这个新的inode类型是**软链接类型**，其**磁盘数据存储的是原目标路径**，操作系统能够根据inode类型识别出它是软链接然后得到原目标路径
	* 原文件/目录地位更高一点，直接引用inode，软链接间接引用inode，所以删除原文件/目录影响软链接（使用）
	* 软链接**能够链接目录**的原因：遍历的时候软链接作为特殊的类型（完整的inode）能够**直接展示符号链接的信息**，而不是展示链接目录下的信息，就不会造成循环遍历

---

* `File` 相当于一个trait特性，对于实现了这个trait的类都可以进行读写操作；在 `fd_table` 中存储的都是实现了这个Trait的对象，其下标就是返回给用户端的 fd
	* 标准输入输出其实就是个普通的结构，实现了File的读写功能来进行IO读写（在 `fd_table` 的0，1位置）
	* `OSInode` 也实现了File，所以用户能够直接根据文件描述符fd来进行读写（`OSInode`的引用也存储在PCB的 `fd_table`中）
	* 管道 `pipe` 也实现了File，创建管道的时候首先会创建一个**循环队列**（里面用来存储管道的数据），接着创建**读和写的管道对象**（都引用循环队列），管道对象的读写就是在循环队列中进行读写

---

* **创建线程**是为了**执行对应的方法**，所以在内核中会创建一个新的TCB，包含新的用户栈，然后返回到用户空间中对应方法的入口来执行
* **创建进程**是为了**执行对应的程序**，会在内核中创建一个新的PCB，其内容和原进程几乎一样（除了到用户空间的返回值不同）；一般接着会调用 `exec()` 执行新的程序，这回替换整个进程管理的用户空间的内容
