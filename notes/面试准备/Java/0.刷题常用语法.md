# 0、输入输出

```java
Scanner in = new Scanner(System.in);
// 读取一行字符串
System.out.println(in.nextLine());
// 读取整数
while (in.hasNextInt()) {
	System.out.println(in.nextInt());
}
```

# 一、数组

## 语法

* 数组大小：`arr.length`
* 字符串长度：`str.length()`
* 集合大小：`set.size()`
* 集合转数组：`集合名.toArray(new 元素类型[数组大小])`（数组元素必须是引用类型）
	* `s=list.toArray(new String[0]);`
* 数组转集合：`Arrays.asList(数组名)`（数组元素必须是引用类型）
	* `List<String> myList = Arrays.asList("Apple","Banana");`
* 字符串不能直接用下标访问，需要转成char数组：`str.toCharArray()`，char数组转回字符串：`new String(charArray, 起始index, 长度)`
* 排序：`Arrays.sort(arr, (Integer a, Integer b) -> a - b;)`，其中后面自定义排序需要数组元素是对象类型 / 数组类型
	* 如果两个int类型的比较相减会溢出可用 `Integer.compare(a, b)`
* 基本类型数组转包装类型：`Arrays.stream(arr).boxed().toArray(Integer[]::new)`

## 常见题型

* 双指针

# 二、String

## 语法

* 根据下标获取字符：`str.charAt(下标)`
* 查找字符/子串起始下标：`str.indexOf(字符/子串)`
* 转成字符数组：`str.toCharArray()`
* 字符数组转字符串：`new String(arr, [起始下标，长度])`
* 子串：`str.substring(起始下标，[不包括的结束下标])
* 数字/字符转字符串：`String.valueOf(数字/字符)`
* 字符串转数字：`Integer.parseInt(字符串)`
* 判断内容是否相等：`str.equals(Object类型参数)`
* 字符串多次累加使用：`StringBuilder sb = new StringBuilder();`
	* `sb.append(字符串)`
	* 转为String：`sb.toString()`

## 常见题型

* 字符串全部反转再部分反转
* KMP：
	* next数组记录最长相等前后缀原因：![[Pasted image 20240226001525.png]]

# 三、Collection

## 1. 单列集合

* `new ArrayList<Integer>()`
	* `add(值)`
	* `remove(下标)`
	* `contains(值)`
	* `get(下标)`
* `new HashSet<Integer>()`
	* 遍历：`for(Integer i : set)`

## 2. 双列集合

* `new HashMap<Integer, Integer>()`
	1. `put(键，值)`
	2. `remove(下标)`
	3. `containsKey(键)` / `containsValue(值)`
	4. `getOrDefault(键，默认值)` 有键就返回值，无键返回默认值
	5. 遍历：`Set<Map.Entry<String, Integer>> set = hm.entrySet()`

# 四、栈/队列

* 栈：`Stack<Integer>()`
	1. `push(值)`
	2. `pop()` 弹出并返回
	3. `peek()` 返回顶端值
	4. `empty()`
* 队列：`LinkedList<>()`
	1. `offer(值)`
	2. `poll()`
	3. `peek()`
	4. `isEmpty()`
* 双端队列：`ArrayDeque<>()`：
	* 能用队列和栈的进/出方法
	* `addFirst()`、`addLast()`、`getFirst()`、`getLast()`
* 优先队列：`new PriorityQueue<>()`
	1. `offer(值)`
	2. `poll()`
	3. `peek()`
	4. `isEmpty()`

```java
// 小顶堆（其中hm为HashMap）
PriorityQueue<Integer> pq = new PriorityQueue<>(
	new Comparator<Integer, Integer>() {
		@Override
		public int compare(Integer a, Integer b) {
			return hm.get(a) - hm.get(b);
		}
	}
);

// 大顶堆
PriorityQueue<Integer> pq = new PriorityQueue<>(
	(a, b) -> hm.get(b) - hm.get(a)
);
```

# 五、二叉树

## 常见题型

* 前/中/后序遍历的递归和迭代
* 层序遍历
* 节点深度（根节点到节点距离结点数）
* 节点高度（节点到叶子节点最远距离结点数）
* 递归子树，通过传参来实现累积前面信息，通过全局变量来得到结果
* 二叉搜索树的中序遍历是从小到大的
* 二叉搜索树删除/修剪可以通过递归的方式判断条件来修建左右子树以及自己（删除根节点可以先找到左子树最右节点作为后继节点，删除左子树中的后继节点，取后继节点代替根节点）
* 二叉搜索树需要累加大于自己结点的值时，可以用右中左遍历，在中的时候累加当前节点值实现从大往小累加（本质还是递归遍历）

# 六、回溯

## 常见题型

* 组合数：给定起始值和终止值，符合条件就加入结果
	* `List<List<Integer>> lists` 中添加全局的 `List<Integer> list` 要用 `new ArrayList(list)`，否则后面会覆盖
* 对于一些分割问题，可以每次分割成两份，前一部分符合条件才递归看后一部分
* 求子集直接在递归函数一开始就将 `cur` 加入到 `ans` 中即可
* 全排列：每次递归都从下标0开始，用一个全局数组 `vis[]` 来维护之前访问过的下标
	* 如果数组有重复元素可以先排序，然后在遍历时如果访问过就跳过

注意：当前递归函数下标是 `idx`，`i`从`idx`开始遍历的时候，调用递归函数是根据 `i` 来计算下一次下标而不是 `idx`


# 七、贪心

## 常见题型

* **摆动序列最长长度**：保留所有尖端点即为最长
* 查看**能否到达终点**只用在遍历的时候计算最大能到达长度
	* 如果还要计算最小步数可统计当前最大长度所需步数，如果当前遍历下标超出了之前步数可走范围就增加步数
* 加油站加油和耗油，只用求（加油-耗油）之和的最小值下标，选择下一个位置即可，因为累加值相对位置是不变的，只是值大小变了
* **多个条件**时选择先满足其中一个，再满足后面的条件
	* 相邻两个孩子评分高的糖果多，总糖果数可以先从左往右保证右边评分高的糖果多，再从右往左保证左边评分高的糖果多（选取原本和当前最大值）
	* 身高和前面有多少个比其高，先按身高从高到低排序，接着再从高往低遍历根据第二个条件放入对应的位置
* **区间重叠**问题：
	* 选取最少数量的值能在所有区间中，可以按照区间头/末尾排序，如果当前区间起始值小于等于前一个区间末尾就可以被前一个区间末尾包括
	* 移除区间使区间不重复，可以按照区间末尾排序，若下一个区间头小于之前的区间末尾就删除
	* 合并区间，可以按照区间头排序来合并
* 获取小于等于n的位数递增的最大数字，可以从右往左遍历，若左边位大于右边位，则左边位--，右边位设置为9，这样可以保证每次减少得最少
* 监控器能够监控父、当前、子节点，要找能监控二叉树所有节点的监控器数，可以通过从下往上后序遍历，先保证下层节点被监控，同时当前节点能不监控就不监控，交给上层节点监控

# 八、动态规划

## 常见题型

* 整数拆分后乘积最大：遍历前面所有数拆分得到一个数 `(i-j)`，剩余的数可以拆即 `dp[i]`，也可以不拆即 `i`，所以dp需要三个数求最大： `dp[i] = Math.max(dp[i], Math.max(dp[j]*(i-j), j*(i-j)));` 
* 整数n个值得二叉搜索树数量：以前面所有值作为根节点的数量是 左子树数量 * 右子树数量：`dp[i] += dp[j - 1] * dp[i - j];`
* 01背包（有目标/容量，每个物品只能用一次）：
	* 二维数组：初始化第0行（视情况初始化第0列），且重量从1开始从左往右遍历（每次还要判断当前容量是否大于等于当前物体重量）
	* 一维数组：直接从容量开始**从右往左**遍历到当前物品重量（视情况初始化 `dp[0]`），外层循环只能是物品
	* 数组能够分为两半使得各自总和相等：取所有数总和的一半作为背包容量，数组元素作为重量和价值，计算 `dp[j]` 得最大价值是否是数组总和一半（求目标值）
		* 任意两块石头粉碎使得最后一块石头重量最小：等价于将所有石头分成重量最接近的两堆，返回两堆差值，做法类似数组分半
	* 非负整数数组选择部分减去另一部分得到值为目标值的数目：由 `left-right=target` 和 `left+right=sum` 可得 `left=(target+sum)/2`，即left作为目标值/容量，`dp[i][j]`表示到元素 i 的目标值为 j 的数目：`dp[i][j] = dp[i-1][j] + dp[i-1][j-nums[i]]`（求目标值）
		* 如果 `abs(target) > sum` 或 `(target + sum) % 2 == 1` 都不满足
		* 初始化时容量为0的dp值为1，因为 `j-nums[i] == 0` 表示这个元素刚好可以作为目标值
	* 如果有两个容量条件还是用二维数组好（对应一个容量的一维），不用初始化
* 完全背包（有目标/容量，每个物品可以用多次）：
	* 二维数组：初始化第0行（视情况初始化第0列），且重量从1开始从左往右遍历（每次还要判断当前容量是否大于等于当前物体重量）
	* 一维数组：直接从当前物品重量开始**从左往右**遍历到容量（视情况初始化 `dp[0]`），组合 -> 外层循环是物品；排列 -> 外层循环是容量
	* 选择零钱总和为target的**组合数**：外层for遍历物体，内层遍历target
	* 选择零钱总和为target的**排列数**：外层for遍历target，内层遍历物体
	* 和为n的完全平方数的最小数：所有小于等于n的平方数可以作为无限的物体，n为容量：`dp[j] = Math.min(dp[j], dp[j-allSq[i]]+1);`
		* 由于是求最小值，所以`dp[0]`初始化为0，`dp[1~n]` 初始化为 `Integer.MAX_VALUE`
		* 如果dp是int类型会出现 `dp[j-allSq[i]]+1` 大于 `Integer.MAX_VALUE`导致溢出为负数，所以需要先判断其是否为整形最大值，如果不是才用递推方程，否则就是 `dp[j]`
	* 判断一个字符串s是否能由字符串数组中的字符串组成（可重复）：将字符串s作为容量（从下标0开始增大字符串），字符串数组作为物品：`dp[i] = dp[i] || 当前字符串能由dp[i-当前物品字符串长度]+当前物品字符串拼接而成`
		* 要注意物品字符串顺序任意，所以容量for外层，物品内层
* 打家劫舍（每个位置有偷/不偷两种状态）：
	* 数组中相邻两个元素不能一起取，且头尾不能一起取，求能取的最大总和：头取(尾不取) -> **前n-1个元素求总和** + 头不取(尾可取可不取) -> **后n-1个元素求总和**
	* 如果是二叉树形式，通过后序遍历：当前不偷=左子树max(偷，不偷) + 右子树(偷，不偷)，当前偷=左子树(不偷)+右子树(不偷)+当前值
* 买卖股票（每个位置有持有/非持有两种状态，也可为多种）：
	* 只能某一天买股票，另一天卖：
		1. 贪心：记录**到目前为止买入的最小值**，遍历的时候除了更新最小值，还计算当前卖出获利是否是最大（只能有一天卖，那只需要遍历找每一天都卖的最大值即可）
		2. dp：`dp[i][0]` 表示第i天持有股票的最大获利，`dp[i][1]` 表示第i天不持有股票的最大获利（这里的**持有股票最大获利只能由前面的持有股票最大获利和当前买股票二者决定**，因为只能有一天买入股票）
	* 每天都可以买股票和卖股票：
		1. 贪心：一旦下一天比今天股票还贵就今天买明天卖（累加所有递增值）
		2. dp：`dp[i][0]` 表示第i天持有股票的最大获利，`dp[i][1]` 表示第i天不持有股票的最大获利（这里的**持有股票最大获利可以由前面的持有股票最大获利、前面非持有股票最大获利和当前买股票三者决定**，因为每天都可以买入股票）
	* 每天都可以买和卖，最多卖两次（卖k次也一样，用循环即可）：
		1. dp：`dp[i][0]`表示当前及前面一次买卖都没有，`dp[i][1]`表示当前第一次持有股票的最大利润，`dp[i][2]`表示当前第一次未持有股票的最大利润（之前/当前卖了一次），`dp[i][3]`表示当前第二次持有股票的最大利润，`dp[i][4]`表示当前第二次未持有股票的最大利润（之前/当前卖了两次）
			* 初始化：`dp[0][1] = -price[0]` -> 第一天第一次买入，`dp[0][3] = -price[0]` -> 第一天第二次买入（买入卖出再买入）
			* 持有股票（j 为奇数）：`dp[i][j] = Math.max(dp[i-1][j], dp[i-1][j-1]-prices[i]);`
			* 未持有股票（j 为偶数）：`dp[i][j] = Math.max(dp[i-1][j], dp[i-1][j-1]+prices[i]);`
	* 隔天才可以卖：`dp[i][0]`表示未持有股票（前面卖），`dp[i][1]`表示持有股票（之前买/现在买），`dp[i][2]`表示未持有股票（今天卖）
* 子序列和子串问题（一个或多个字符串，两个区间来dp）：
	* 连续问题 -> 递推表达式包括结尾；非连续问题 -> 不包括结尾
	* 递增子序列（不用连续）：`dp[i]`表示以 `s[i]` 结尾的最长递增子序列，外循环遍历字符串s，内循环遍历前面所有结尾的下标
		* 注意要用一个额外的变量记录最大值
	* **最长公共子序列**（不用连续）：`dp[i][j]` 表示字符串s1到下标 i 和字符串s2到下标 j 的最长公共子序列（可以不连续->不用包含结尾）：
		1. 如果结尾相同： `s1[i] == s2[j]` -> `dp[i][j] = dp[i-1][j-1]+1`
		2. 否则 `s1[i] != s2[j]` ->`dp[i][j] = max(dp[i-1][j], dp[i][j-1])`
	* **最长公共子串**（要连续）：`dp[i][j]` 表示字符串s1到下标 i 和字符串s2到下标 j 的以 `s1[i]` 和 `s2[j]` 结尾的最长公共子串
		1. 如果结尾相同 `s1[i] == s2[j]` -> `dp[i][j] = dp[i-1][j-1]+1`
		2. 否则 `s1[i] != s2[j]` ->`dp[i][j] = 0`
	* 判断 s1 是否为 s2 的子序列：
		1. dp：与最长公共子序列相同，`dp[i][j]`为不包括结尾的最大长度，最后返回 `dp[s1.length()-1][s2.length()-1]==s1.length()`（也可以用当前s1子串是否为s2子串的子序列来作为递推式）
		2. 双指针：如果 `s1[i] == s2[j]`，i 和 j 都往后走，否则只有 j 往后走，最后看 i 是否走到结尾
	* 计算在 s2 的子序列中 s1 出现的次数（s1为s2的子序列的个数）：`dp[i][j]`表示 s1 在下标 i-1 处子串为 s2 在下标 j-1 处子串中子序列出现次数
		1. 初始化：s1为空的时候s2子序列长1：`dp[0][0~s2.length()] = 1`
		2. 结尾相同：包括 s1 在 i-2 处子串为 s2 在 j-2 处子串中子序列出现次数 `dp[i-1][j-1]`（结尾作为子序列结尾） + s1 在 i-1 处子串为 s2 在 j-2 处子串中子序列出现次数 `dp[i][j-1]`（结尾不作为子序列结尾），总和：`dp[i][j] = dp[i-1][j-1] + dp[i][j-1];`
		3. 结尾不同：s1 在 i-1 处子串为 s2 在 j-2 处子串中子序列出现次数 `dp[i][j] = dp[i][j-1];`
	* 使得两个字符串相等时需要删除的最少字符个数：
		1. dp1：`dp[i][j]`表示 `s1[0~i-1]` 和 `s2[0~j-1]` 需要删除的最少字符数
			1. 初始化：长度为0的字符串和长度为len的字符串最少需要删除len个字符：`dp[0][j] = j, dp[i][0] = i`
			2. 结尾相同：`dp[i][j] = dp[i-1][j-1];`
			3. 结尾不同：`dp[i][j] = Math.min(dp[i][j-1], dp[i-1][j]) + 1;`
		2. dp2：s1长度 + s2长度 - s1和s2的最长公共子序列
	* s2转换为s1的最少操作数，可插入、删除、修改：
		1. dp：`dp[i][j]`表示 `s1[0~i-1]` 与 `s2[0~j-1]` 相等所需要的最少操作数
			1. 初始化：s1长度为0时，s2所有字符都要删除：`dp[0][j]=j`；s2长度为0时，s2需要增加字符到和s1一样：`dp[i][0]=i`
			2. 结尾相同：`dp[i][j] = dp[i-1][j-1];`
			3. 结尾不同：包括了替换、插入、删除操作：`dp[i][j] = Math.min(dp[i-1][j-1], Math.min(dp[i][j-1], dp[i-1][j])) + 1;`
* 回文串（起始和结尾作为区间来dp）：
	* 回文子串个数：
		1. i 作为子串中心遍历，以 i 为中心 + 以 i 和 i+1 为中心
		2. dp：`dp[i][j]`表示区间 `[i,j]` 是否为回文串，遍历的时候 i 需要从 `s.length()-1`开始到0，j 需要从 i 开始到 `s.length()-1`，因为**会用到区间内所有子区间**；递归方程只有当 `s[i] == s[j]` 的时候才可能是：
			1.  `i == j` -> `dp[i][j] = true`
			2. `j == i+1` -> `dp[i][j] = true`
			3. 否则 -> `dp[i][j] = dp[i+1][j-1]`
	* 最长回文子序列：dp做法同回文子串差不多，`dp[i][j]`表示区间 `[i,j]` 中最长回文子序列
		1. 结尾相同：若区间间隔<=1 -> `dp[i][j] = j - i + 1;`；否则 -> `dp[i][j] = dp[i+1][j-1] + 2;`
		2. 结尾不同：`dp[i][j] = Math.max(dp[i][j-1], dp[i+1][j]);`
		3. 最后返回的是 `dp[0][s.length()-1]`

# 九、单调栈

## 常见题型

* 求元素左边/右边第一个比他大/小的元素位置
	* 找出数组中元素右边大于当前元素的距离：使用一个**单调栈来存放递减的元素的下标**（栈底到栈顶递减），如果当前元素值大于栈顶对应的元素值，就代表栈顶所在元素遇到了第一个在其右边大于它的元素，所以出栈且将该栈顶元素位置记录当前元素到其距离
	* 找出**循环数组**中元素右边大于当前的元素值：将数组复制一遍放到右边，计算**合并后的数组的所有结果**，返回**前半部分**
		* 取余优化：`i` 遍历的范围 `[0, 2*s.length)`，然后用到 `i` 的地方都取余 `i % s.length`
	* 接雨水：
		1. 按列遍历：对于当前列可以接的雨水数 = min(右边**最高**列，左边**最高**列) - 当前列高度
			* 可以预处理计算每个元素其左边最高列值和右边最高列值
		2. 按行遍历：单调栈记录**栈底到栈顶递减**的列高度的下标，遇到高的就**弹出栈顶作为mid值**，如果栈还有值就可以构成（栈顶，mid，当前值）的凹槽来存水，当前凹槽存水值 = （min(栈顶对应高度，当前值) - mid） * （当前下标 - 栈顶值下标 - 1） 
	* 找柱状图中最大的矩形面积：遍历每一列作为矩形的高，最大面积 = 当前列高度 * （右边**第一个小于**当前列的下标 - 左边**第一个小于**当前列的下标 - 1）
		* 可通过预处理计算每个元素右边和左边第一个小于他的元素下标

# 十、图

## 常见题型

* 岛屿问题（一般用dfs，进入dfs表示开始处理这个点）：
	* 图用二维数组表示，0b表示水，1表示岛屿，求哪些岛屿会被水包围：**遍历边界岛屿点**，以它们为起点进行dfs，所有相连的岛屿都不会被包围
	* 一个m * n岛屿上左边界与太平洋连接，下右边界与大西洋连接，雨水会从岛屿高处往低处流，求能够流到太平洋和大西洋的点：
		1. **先遍历与太平洋连接**的上左边界岛屿点，所有**相邻的且周围高度 >= 当前高度的岛屿点**都可以连通
		2. **再遍历与大西洋连接**的下右边界岛屿点，所有**相邻的且周围高度 >= 当前高度的岛屿点**都可以连通
		3. 最终遍历一遍看哪些点既与太平洋连接，又与大西洋连接
	* 一个n * n岛屿，只能将一个0变成1，求变成后最大岛屿大小：
		1. 先遍历岛屿进行dfs将**每个小岛屿进行单独的标记**，并记录该标记对应的大小
		2. 然后再遍历一次岛屿，**将0修改成1，看四个方向是否有岛屿**，有就累加大小（注意不要加了重复标记的岛屿）
	* 只有一个岛屿，计算其周长：
		1. 法一：dfs遍历所有岛屿节点，**每次往四个方向的时候都看是否是海**，如果是周长就+1，如果不是就dfs递归
		2. 法二：直接遍历所有节点，如果是**岛屿就+4**，同时如果其**上面是岛屿就-2，左边是岛屿就-2**
* 单词接龙：给定初始字符串、结尾字符串、可用字符串列表，每次改变初始字符串的一个字符得到可用字符串列表中的下一个字符串，求能够变成结尾字符串的最小次数：
	1. 初始字符串**依次改变所有字符**，如果改变后的字符串在字符串列表中就将改变后字符串**加入到队列**，通过**广度优先搜索**的方式来得到改变的最小次数（复杂度：字符串列表长度 * 字符串长度 * 26字母）