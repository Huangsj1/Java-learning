# 一、HTTP报文

* HTTP报文结构：
	1. 请求行：请求方法、URI、HTTP版本
	2. 请求头：通过 `字段名:值` 的方式包含多个字段，包括 `Host`目的主机名、`Connection`连接模式、`Cookie`
	3. 空行：分隔
	4. 请求体：请求的数据

![[Pasted image 20240320104102.png]]

# 二、HTTP缓存技术

## 1. 强制缓存

只要浏览器缓存没过期就直接用浏览器缓存

1. 浏览器每次响应的时候都会在 `Response` 头部**添加 `Cache-Control` 字段记录资源过期的相对时间**
2. 当浏览器请求资源时会先通过请求资源的时间与 `Cache-Control` 中设置的过期时间计算缓存中的资源是否过期，**没有则直接使用缓存，否则进入协商缓存**

## 2. 协商缓存

浏览器通过发送资源请求给服务器，服务器判断是否过期，没过期就返回 `304` 让浏览器读取其缓存，否则返回 `200` 以及请求结果

1. 浏览器每次响应的时候也会在 `Response` 头部添加 `Last-Modified` 字段记录资源最后修改时间、`ETag` 字段唯一标识该资源
2. 当浏览器的发现 `Cache-Control` 记录的过期时间到了才会进行协商缓存：
	1. 如果记录了 `ETag` 字段就在请求头中添加 `If-None-Match` 字段设置为 `ETag` 值发送给服务器；服务器根据 `If-None-Match` 值是否等于现在该资源的 `ETag` 值来决定返回 `304` 让浏览器用缓存还是返回 `200` 并且返回新数据
	2. 如果没有 `ETag` 字段就看是否有 `Last-Modified` 字段，有的话就在请求头中携带 `If-Modified-Since` 字段设置为 `Last-Modified` 的值发送给服务器；服务器根据 `If-Modified-Since` 值是否等于资源最后修改时间，等于就返回 `304` 让浏览器用缓存，否则返回 `200` 并且返回新数据

![[Pasted image 20240320103339.png|310]]![[Pasted image 20240320103349.png|310]]
![[Pasted image 20240320103400.png]]

# 三、HTTPS

HTTPS解决了HTTP的不安全问题，在TCP和HTTP之间加入了 **SSL/TLS安全协议**，使得报文能够加密传输（由于SSL/TLS在用户态，所以不能够对在内核态的TCP报文头部加密）

由于HTTP是明文传输，存在三个风险：

1. 通信内容被**窃听**
2. 通信内容被**修改**
3. **冒充**服务器接收客户端信息和发送给服务端

而HTTPS加入了 `SSL/TLS` 协议来解决上述风险：

1. 信息加密
2. 校验机制
3. 身份证书

## 1. 信息加密

HTTPS采用**对称加密**和**非对称加密**相结合

1. 通信建立前通过**非对称加密方式交换会话密钥**
	* 服务器有自己的私钥以及对应的公钥，将公钥发送给客户端
2. 之后的数据传输就通过**会话密钥来进行对称加密**（对称加密更快）
	* 客户端通过公钥加密数据，只有服务器有私钥能够解密
	* 服务器通过私钥加密的数据客户端能通过公钥解密（公钥泄露了别人只能获取并解析服务器加密的内容，无法知道里面数据是什么意思，因为无法解析客户端请求的内容）

## 2. 校验机制

1. **哈希算法**（保证数据完整）：无论是客户端还是服务器**发送的数据都可能被修改**，所以需要通过对加密后的数据计算一个**哈希值**一起发送，接收数据的时候只需要对数据也进行哈希看得到的值和传过来的哈希值是否一致来判断是否修改
2. **数字签名算法**（保证数据来源可靠）：但是整个**数据和哈希值都可能被替换掉**（只要知道了哈希计算方法就可以整块替换），所以**服务器需要通过私钥对哈希值进行加密得到数字签名**，这样客户端就能够通过公钥解析出服务器用私钥加密的数字签名得到哈希值（其他用户无法获取服务器的私钥来加密）

![[Pasted image 20240320123959.png]]

## 3. 身份证书

**中间人可能假扮成服务器**，通过构建一对公私钥来**将公钥传给客户端，同时接收服务器的公钥**，这样不仅能够获取用户端请求，还能解析服务器响应

所以客户端需要能够**检验接收的公钥是否是服务器传来的**，于是服务器需要将公钥以及自身信息交给一个独立的即构——数字证书认证即构CA，让**CA来生成证书给服务器**，然后服务器就能将证书发给客户端，让**客户端来检验**该证书是否真实且是服务器生成的（中间人也可以申请注册证书，但是无法伪造服务器的证书，因为**CA需要申请者传来公钥以及身份信息，包括域名等，然后CA通过发送邮箱等方式确认域名对应的身份信息**）

* CA通过自己的**私钥来对申请者的公钥以及身份信息来生成数字证书**（对所有信息进行哈希后，再对哈希值用私钥加密）
* 浏览器、服务器、操作系统等都有对应CA的公钥，能够解析对应的CA生成的数字证书得到公钥以及申请者的身份信息（对所有信息进行哈希得到哈希值1，然后通过公钥对CA中的加密哈希值解密得到哈希值2，检查1是否等于2）

![[Pasted image 20240320124437.png]]

![[Pasted image 20240320125113.png]]

### SSL/TLS的四次通信（RSA算法）

1. `Client Hello`：客户端发送加密请求，包括TLS协议版本、**生成的随机数 `Client Random`**、加密套件等
2. `Server Hello`：服务器响应，包括确认TLS协议版本、**生成的随机数 `Server Random`**、确认加密套件、**服务器的数字证书**（公钥以及身份信息）
3. 客户端回应：
	1. 校验数字证书**得到公钥**
	2. **生成随机数 `pre-master` 并用公钥加密**，发送给服务器；并用三个随机数用商量好的加密算法**生成会话密钥**
	3. 通知服务器**之后的通信用会话密钥通信**
	4. 客户端握手结束通知，将所有握手数据做个摘要供服务端检验
4. 服务器回应：
	1. 接收到 `pre-master` 之后同客户端一样用三个随机数用商量好的加密算法**生成会话密钥**
	2. 回应客户端之后的通信用会话密钥
	3. 服务端握手结束通知，将所有握手数据也做个摘要供客户端检验

![[Pasted image 20240320122429.png]]

# 四、HTTP 1.1、2、3

![[Pasted image 20240320144512.png]]

## 1. HTTP 1.1

HTTP1.0和1.1区别：

1. HTTP1.0为**短连接**（TCP连接），每个连接只能发送一个请求和响应；HTTP1.1为**长连接**，每个连接可以发送多个请求和响应
2. HTTP1.1支持**管道传输**，第一个请求发出去了，不用等待其响应就可以发送第二个请求（默认不使用）
3. HTTP1.0**没有Host字段**（域名）；HTTP1.1**有Host字段**
	* 多个主机名可以绑定到同一个ip地址，所以带上域名可以找到对应的主机
4. HTTP1.1添加了更多的状态码

![[Pasted image 20240320104157.png]]

## 2. HTTP 2

改进：

1. **压缩头信息**：如果多个请求头是一样/类似的，在客户端和服务器都会缓存一张头信息表，这样传输的时候头信息用索引即可
2. **二进制格式**：请求报文从原来的纯文本转成了二进制，加快了计算机对于报文中数据的读取
3. **并发传输**：每个HTTP请求当作一个 `Stream`，每个 `Stream` 里面包含多个 `frame`帧，以frame为单位传输，不同Stream中的frame并发传输，接收端会根据 `Stream ID` 来有序组成原请求信息
4. **服务器主动推送**：服务器可以主动发送 `Stream` 到客户端

![[Pasted image 20240320145345.png]]

缺点：虽然能够并发发送数据，但是其是**基于TCP**的，TCP需要保持收发的字节是完整及有效的，如果**当前Stream数据丢失部分，后面的Stream都会阻塞在队列中无法处理**

![[Pasted image 20240320145546.png]]

## 3. HTTP 3

将下层从TCP改成**UDP**，使用**基于UDP的Quick协议**

1. **无队头阻塞**：某个Stream发生数据丢失值会阻塞当前流，后面流不受影响
2. **更快建立连接**：HTTP 2基于TCP和SSL/TLS需要经过TCP三次握手和TLS四次握手（TCP是在内核中的，TLS基于 `openssl`库的）；而**Quick协议包含了TLS，只需要三次握手即可建立连接**
3. **连接迁移**：TCP是通过四元组来确定当前连接的，如果设备从流量转成了WIFI，ip发生了变化，就需要断开连接再重新建立连接；而**Quick是通过连接id来标识当前连接**，即使ip变化了，仍**可以通过上下文信息（连接id、TLS密钥等）来复用原来连接**

![[Pasted image 20240320150122.png]]

![[Pasted image 20240320150111.png]]

# 五、杂项

## 1. 状态

HTTP是无状态的，但是可以通过保存服务器传来的用户对应的 `sessionId` 来保存用户信息

## 2. HTTP和RPC

纯裸的TCP是一个无边界的数据流，不同消息之间的字节连接在一起，所以需要上层协议来定义消息边界，包括HTTP、各类RPC等

RPC是一种调用方式，调用远程服务器的函数来获得结果

1. **RPC主要用于 C/S 架构**，HTTP主要用于 B/S 架构
	1. RPC：各种联网软件只需要跟对应的服务端建立连接即可
	2. HTTP：浏览器需要能够和各种服务器建立连接，需要有个统一标准
2. 常用的 HTTP1.1 中请求头信息较冗余，请求体需要将数据序列化成 JSON 格式也会出现冗余数据；而**RPC采用体积更小的 Protobuf 或其他序列化协议去保存结构体数据**，所以性能更好（但是HTTP2更好）
3. RPC出现时间较早，比主流的HTTP1.1性能更好，所以大部分公司依然在用

## 3. HTTP和WebSocket

1. TCP是全双工的，HTTP是半双工的，**WebSocket是全双工**的
	* HTTP只能由客户端发送数据到服务端（类似扫码登录功能，可以通过定时轮询/长轮询的方式来实现服务器推送）
		* 定时轮询：每个一段时间客户端就向服务器重复发送请求
		* 长轮询：客户端发送请求后等待较长一段时间来等待服务器请求
	* WebSocket能够实现网页游戏等需要客户端和服务器频繁交互的场景

* 流程：
	1. 客户端发送HTTP在请求头中包含升级协议成 `WebSocket`
	2. 服务端如果可以升级就返回101状态码表示成功升级
	3. 之后就建立了 `WebSocket` 连接，可以进行全双工通信

![[Pasted image 20240320160609.png|400]]

## 4. XSS和CSRF

* XSS：恶意代码注入
* CSRF：用户访问正常服务器获得Cookie，之后访问恶意网站的时候会发送请求且携带Cookie，然后恶意网站获得其Cookie之后携带Cookie让其访问正常服务器来进行恶意操作
	* 通过 `token` 可以防止：恶意网站不能直接获取token，在前端页面代码中请求的时候会写好携带token，而访问恶意网站请求不会