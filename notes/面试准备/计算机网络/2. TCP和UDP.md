# 一、报文结构

## 1. TCP

![[Pasted image 20240319102228.png]]

* **源端口号和目的端口号**，各自2字节
* SYN序号和ACK序号，各自4字节
* 标志位，6位
* 16位窗口大小

## 2. UDP

![[Pasted image 20240319103134.png]]

* **源端口号和目的端口号**，各自2字节
* UDP长度、UDP校验和

# 二、TCP三次握手和四次挥手

* 只包含ACK的报文不会重传（需要对方重传上一个报文来让我重新发送ACK报文）

## 1. 三次握手

![[Pasted image 20240320171205.png|400]]

1. 两次握手不行：
	1. 服务器第回复可能丢失，这时服务器已经开启连接，而客户端会重新发送请求连接
	2. 第一次：服务器知道客户端可发送；第二次：客户端知道服务器可发送可接收；第三次：服务器知道客户端可发送可接收
2. 第二次回传SYN原因：SYN作用是同步，回传表示二者之间的通信没有问题

---

前两次握手不能携带数据，**第三次握手可以携带数据**

---

**初始序列号随机**的原因：如果都从同一个值开始（例如0），可能会出现**历史报文被下一个相同四元组的连接接收处理**（历史报文如果被阻塞了，这时如果创建了另一个相同四元组的连接，且序列号到达了历史报文对应的序列号，如果接收到了历史报文就会出现数据错误）

即使随机也有可能出现上面讲的情况，所以还会有时间戳等方式验证

### Linux建立连接过程

* **SYN队列**：在接收到客户端的SYN报文时会创建一个半连接对象加入到SYN队列中，之后逐个发送第二次握手的SYN+ACK报文
* **Accept队列**：接收到客户端的ACK报文后，取出对应半连接兑现，创建一个新的连接对象加入到Accept队列中；应用通过`accept()`函数从Accept队列中获取连接对象

![[Pasted image 20240320165351.png]]

#### SYN攻击

攻击者不断发送SYN请求到服务器，导致SYN队列满了，于是就会丢弃后续的连接请求

解决办法：

1. 增大SYN队列
2. 开启syncookies 功能，在不使用 SYN 半连接队列的情况下成功建立连接

![[Pasted image 20240320170341.png]]

## 2. 四次挥手

![[Pasted image 20240320171227.png|400]]

1. 三次挥手不行（将服务器的第二次和第三次结合）：服务器还需要处理没处理完的请求
2. 第四次挥手客户端要等待2MSL，因为最后一次请求确认可能丢失，如果丢失了服务器会重新发送第三次的FIN，所以客户端需要等待是否受到第三次重复的FIN

### 1. 服务器大量出现TIME_WAIT原因

1. HTTP使用**短连接**：短连接默认是服务器主动发起TCP连接终止请求
2. HTTP**长连接超时**：长连接超时后服务器主动发起TCP连接终止请求

### 2. 服务器大量出现CLOSE_WAIT原因

代码问题导致了服务器没有对对应的 `socket` 调用 `close()` 函数来发送FIN请求

# 三、Linux下Socket编程

* 通过 `Socket` 库可以在用户态通过库函数来选择 `TCP / UDP` 协议进行通信
* `TCP/UDP, IP, MAC` 都是在操作系统内部进行封装/解封装的
* 操作系统最后通过网卡驱动程序在MAC包前面加上报头信息和包尾加上FCS检错码，之后才发送

![[Pasted image 20240320091337.png|320]]![[Pasted image 20240320091913.png|310]]

发送流程：

1. 应用程序通过 `Socket` 的接口进行系统调用进入到内核态进行数据的发送
2. 内核态的 `Socket` 相关部分会申请一个**缓冲区用来存储需要发送的数据**，对于每一次要发送的数据都会**创建一个 `sk_buff` 类型的对象来存储数据**，然后将这个对象**放入到 `Socket` 的缓冲区**中
3. 网络协议栈从 `Socket` 缓冲区中取出 `sk_buff` 对象，**经过TCP/IP/MAC层层封装**（就是在 `sk_buff` 的对应成员中添加该层的报文信息） ，将**封装后的对象加入到网卡的发送队列**中，并通过软中断通知网卡的驱动程序来处理发送请求
4. **驱动程序会将发送队列中的 `sk_buff` 对象挂到 DMA 的 `Ring Buffer` 中**，之后**网卡就能直接从 `Ring Buffer` 中通过DMA读取里面的 `sk_buffer` 对象来进行发送**

![[Pasted image 20240320093057.png]]![[Pasted image 20240320093038.png]]

## 1. Linux下的套接字

### 1. 套接字的基本概念

* **一个文件描述符指向一个套接字**，每个套接字包括当前的**ip地址和端口号**，同时还包含两个缓冲区：**读缓冲区和写缓冲区**
* 每个TCP连接通过套接字对唯一标识

![[Pasted image 20240319112126.png]]

### 2. 网络字节序

* 小端法：低位存低地址，用于pc本地存储
* 大端法：高位存低地址，用于网络存储/传输

所以**ip地址的点分十进制的字符串**可以和**网络字节序的ip地址**进行相互转换：

* `htonl`：本地 -> 网络（IP）
* `htons`：本地 -> 网络（port）
* `ntohl`：网络 -> 本地（IP）
* `ntohs`：网络 -> 本地（port）
* `int inet_pton(int af, const char* src, void* dst)`：将src指向的点分十进制字符串转成网络字节序（大端法）存储到dst中，af指定了ipv4/6
* `const char* inet_ntop(int af, const void* src, char* dst, socklen_t size)`：将src指向的网络字节序转成点分十进制字符串存储到dst缓冲区中，size指定了缓冲区大小，af指定了ipv4/6

### 3. sockaddr结构

网络编程的时候绑定套接字需要用到 `sockaddr` 结构，里面包含了当前ip协议、ip地址和端口号

下面是创建一个 `sockaddr` 对象以及绑定创建的空套接字 `fd` 的过程：

![[Pasted image 20240319112144.png]]

## 2. TCP通信流程

服务器首先创建**一个套接字负责监听**，当客户端创建套接字进行连接请求的时候，服务器再创建一个套接字与其配对进行连接通信

![[Pasted image 20240319145437.png]]
![[Pasted image 20240320174546.png|310]]![[Pasted image 20240320174655.png|310]]

### 1. 服务器流程

1. `int socket(int domain, int type, int protocol)`：创建socket
2. `int bind(int sockfd, const struct sockaddr *addr, socklen t addrlen)`：绑定赋值后的服务器地址结构到socket中
3. `int listen(int sockfd, int backlog):`：设置监听客户端上限数量
4. `int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen)`：阻塞监听客户端连接（**获取的是已经建立了三次连接的套接字**）
	* `sockfd` 为服务端socket的fd
	* `addr`为用来接收客户端sockaddr信息的对象
	* `addrlen`传入时为sockaddr结构体大小，传出时为实际大小
1. `read(fd)`：读socket获取客户端数据
2. `write(fd)`：写数据到socket客户端
3. `close()`：关闭连接

![[Pasted image 20240319151913.png|310]]![[Pasted image 20240319151946.png|410]]![[Pasted image 20240319152012.png|410]]

#### accept() 实际流程

`accept()` 只是从 `Accept()` 队列中获取已经建立好连接的套接字，所以没有使用该函数也会三次握手建立连接

![[Pasted image 20240320174925.png]]

### 2. 客户端流程

1.  `socket()`：创建socket
2. `int connect(int sockfd, const struct sockaddr* addr, socklen_t addrlen)`：与服务器建立连接（不用 `bind`，隐式绑定）
	* `sockfd`：创建的socket的fd
	* `addr`：服务器地址结构
	* `addrlen`：addr结构体大小
1. `read(fd)`：读socket获取服务端数据
2. `write(fd)`：写数据到socket服务端端
3. `close()`：关闭连接

![[Pasted image 20240319152052.png]]

# 四、UDP实现可靠传输

## 1. TCP的缺点

TCP的缺点可以参考HTTP3的优点，其解决了大部分TCP缺点

1. **升级工作困难**：TCP处在内核态，升级的话需要升级整个内核，同时还要保证向后兼容
2. **建立连接的延迟**：需要三次握手 + 四次SSL/TLS握手
	* 可通过 `Fast Open` 技术在第一次握手的时候服务器传递包含了多种信息的 `Cookie`，之后的连接客户端只要发送 `Cookie` 的同步请求就能够快速建立连接
3. **队头阻塞**：只有当前TCP段被接收了，应用层才能获取后面的TCP段
4. **网络迁移**：当切换网络/ip地址时需要重新建立连接

## 2. 基于UDP实现可靠传输（QUIC）

基于UDP的可靠传输是**在应用层支持并完善TCP的特性**，包括**可靠传输、流量控制、拥塞避免**，同时解决**队头阻塞、建立连接时间长、需要迁移重连**等问题，具体实现是 QUIC 协议

![[Pasted image 20240320214154.png|310]]![[Pasted image 20240320214202.png|320]]

1. **可靠传输**：通过严格递增的 `Packet Number` 能够确认是哪一个包，实现了乱序确认；通过 `Stream ID + Offset` 能够实现可靠性
2. **流量控制**：每个 `Stream` 一个滑动窗口，互不影响
3. **拥塞避免**：应用层实现TCP的拥塞避免，同时能快速更新替换算法
4. **队头阻塞**：每个 `Stream` 一个滑动窗口，互不影响
5. **快速连接**：采用TLS1.3在连接的时候交换公钥
6. **迁移连接**：通过连接id唯一标识，在ip/端口发生变化不需要重连

### 1. Quic的可靠传输

#### 1. Packet Header

Quic发送的单位是 `packet` 报文：

1. `Long Packet Header` 用于首次建立连接，需要三次握手（协商连接ID、建立SSL/TLS连接等）
2. `Short Packet Header` 用于后面的数据传输，每个 `packet` 都有严格递增的 `PacketNumber`，也就是**超时重传的 `packt` 的编号也需要递增**

![[Pasted image 20240320215502.png]]

* TCP超时重传：重传的报文SYN序列号与原来一致，会导致客户端接收到ACK的时候不知道是哪一个的ACK，导致RTT和RTO计算不准确
* Quic超时重传：重传的报文SYN序列号严格递增，这样就能知道收到的是哪一个报文的ACK

![[Pasted image 20240320215916.png]]

#### 2. Quic Frame Header

每个 `packet` 里面包含多个 `frame`，`frame`可以有多种不同类型（例如：每一条消息可以看作是一个 `Stream`，每个 `Stream` 可被分为多个 `frame` 帧来放到 `packet`中）

* `Stream ID` 用来标识不同的消息
* `Offset` 标识当前消息的偏移量
* `Stream ID + Offset` 可以**实现数据的有序性**：在超时重传时 `Packet Number` 递增，但是可以通过里面的帧的 `Stream ID, Offset` 来确定这属于哪一个消息的哪一帧 

![[Pasted image 20240320215405.png|310]]![[Pasted image 20240320215413.png|310]]

#### 3. 乱序确认

因为 `Packet Number` 严格递增，所以可以实现乱序确认

![[Pasted image 20240320221249.png]]![[Pasted image 20240320221255.png]]

### 2. Quic的流量控制

每个 `Stream` 都有其独立的滑动窗口，各自独立互不影响

#### 1. Stream级别流量控制

* 最大接收窗口：左边界为已经传到应用层的数据，有边界为最大接收的 `Stream Offset`
* 接收窗口：左边界为收到的最大偏移字节数，右边界同最大窗口右边界

![[Pasted image 20240320221325.png]]

#### 2. Connection级别流量控制

设置所有 `Stream` 窗口总共的最大窗口

![[Pasted image 20240320222026.png]]

### 3. Quic的拥塞控制

在**应用层**实现了TCP的慢开始、拥塞避免、快重传、快恢复等，能够**快速迭代更新拥塞控制算法**

### 4. Quic解决队头阻塞

不同的 `Stream` 有着不同的滑动窗口接收，所以各个 `Stream` 互相独立，不会出现队头阻塞

![[Pasted image 20240320222053.png]]

### 5. Quic更快建立连接

* 初次建立连接只需要1RTT，使用TLS1.3同时进行密钥协商
* 之后建立连接只需要0RTT，应用数据和Quic握手数据可以一起传送

![[Pasted image 20240320222319.png]]

### 6. Quic的迁移连接

通过**连接id唯一标识当前连接**，所以ip/端口发生变化不影响

# 杂项

## 1. 为什么TCP要MSS分块

![[Pasted image 20240319162105.png]]

* TCP数据块最大长度为MSS，当HTTP请求超过了该长度要进行拆分
* IP数据快最大长度为MTU（一般1500字节），当TCP报文超出了需要拆分

如果TCP不将数据根据MSS分块，而是直接将所有数据交给IP根据MTU来分片：当出现**IP其中一片丢失了**，由于IP是无连接不可靠的，不会进行重传，所以**接收方的IP层无法组成完整的一份TCP报文，就不会传给TCP层处理**，超时了之后TCP层就需要**重新发送完整的一份数据，即IP需要重传所有分片**

## 2. 端口号复用问题

### 1. TCP和UDP是否可以用同一个端口号

由于内核中有TCP模块和UDP模块，它们是分开的，所以在IP层解析的时候会**根据ip报文中传输层协议来交给不同的上层模块处理**

![[Pasted image 20240320223907.png|500]]

### 2. 服务器的多个TCP能否绑定同一个端口

只要设置的ip不同就可以

### 3. 客户端端口可以重用吗

由于TCP连接是由四元组决定的，所以只要有一个不同都可以，所以只要服务器ip/端口不同就可以

