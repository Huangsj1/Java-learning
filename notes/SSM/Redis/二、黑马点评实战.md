# 一、短信登陆

## 1. 基于session登录

![[d0e522ca3093e35e93b7a08201dff6b.jpg]]

* 使用 `ThreadLocal` 原因：每个请求都是一个线程，对于多个不同用户的请求，如果用的是共享变量存储用户信息，会导致多个线程的用户信息互相干扰（后面的覆盖前面的），所以每个线程都需要有自己的用户信息，这样在拦截器中就可以先根据请求的sessionId从session中获取用户信息，如果用户已登录/存在，就将用户信息存储到 `ThreadLocal` 中并放行，这样后面再查询用户信息就可以**直接从 `ThreadLocal` 中获取**，而不用从session中获取

### 共享问题

存储在session中的用户信息在不同的tomcat服务器中不会共享，可以通过将用户信息存储到redis中，然后不同的服务器都可以从redis中获取

![[ac8024d413bfc0091010f0cbe21cc71.jpg]]

## 2. 基于Redis登录

![[ce934b8101824989c0190195d830fef.jpg]]![[1b80e308580af79fe2de059d40a60a8.jpg]]

redis存储用户信息方式：

![[cba7745ced87989a2249534f5e622aa.jpg]]

* 基于session登录会将**用户信息保存到session中**，在客户端保存sessionId，请求时携带sessionId给后端，后端就能够从对应的session中获取用户信息
* 基于redis登录会将**用户信息保存到redis中**，键为随机的token值，为了在校验中能够根据token获取用户信息，需要在登陆的时候将token返回给客户端，这样客户端每次请求都携带token就能够在后端校验
	* 短信验证码：`key` 为手机号
	* 用户信息：`key` 为随机生成的token，因为token需要返回给客户端，会暴露信息

### 拦截器刷新时间

原本的拦截器在拦截到需要登陆的操作才会刷新Redis中用户信息时间，但是实际上**对所有操作都需要刷新时间**，所以多定义一个拦截器在前面拦截所有的消息来刷新时间，之后的那个原本的登录拦截器只用从 `ThreadLoacl` 中看是否能获取用户信息来判断是否拦截

![[e8fc2889cf18e61f40ab09b44ca85c7.jpg]]

# 二、缓存更新

## 1. 缓存更新策略

缓存的使用：

![[edd40fa7425047507444f37b3d39ddc.jpg]]

缓存更新策略：

![[d70dff91e188f2ecaf30f2c919c2570.jpg]]![[24fb86b57820f03919039bf9f3f747c.jpg]]![[4f51b74c41e93cb34895f8c7b53e4c7.jpg]]

无论是否加 `@Transactional` Redis操作都会立刻执行，且不会回滚

* 先操作缓存再操作数据库：由于操作数据库时间较长，会导致一个线程删除缓存后，其他线程读取时从数据库中读取旧数据到缓存中
* 先操作数据库再操作缓存：操作完数据库后到操作缓存之间时间间隔短，所以出现不一致概率低

CAP存在的多线程并发问题：

![[4c41b472cb57874400f87a725b96685.jpg]]

![[Pasted image 20240306085724.png]]

## 2. 缓存存在的问题

### 1. 缓存穿透

用户请求的数据在缓存和数据库中**都不存在**，不断发送这样的请求会给数据库带来压力

解决方法：

1. 手动检验请求路径的有效性
2. 在缓存中添加null值表示该请求的数据不存在
3. 添加布隆过滤器来提前判断该数据是否存在

![[2096208bcc442f87c80aaf9c392d2d3.jpg]]

![[0f20889e2c788f728b17c193d644a6c.jpg]]

![[Pasted image 20240306094906.png]]

### 2.缓存雪崩

同一时段**大量的缓存key同时失效**或者**Redis服务宕机**，导致大量请求到达数据库，带来巨大压力

解决方法：

1. 不同的key添加不同的TTL
2. 利用Redis集群提高可用性
3. 限流

![[b49b1938f89a5f10406e850e703a05d.jpg]]

### 3. 缓存击穿

缓存击穿问题也叫**热点Key问题**，就是一个被**高并发访问并且缓存重建业务较复杂的key突然失效**了，无数的请求访问会在瞬间给数据库带来巨大的冲击

解决方法：

1. 互斥锁：只让一个线程进行缓存业务重建，其他需要访问的线程等待
	* 因为这里有特定的逻辑操作，普通的 `synchronized` 和 `lock` 都不能满足，所以可以通过在redis中 `setnx <互斥锁>` 来实现：如果没有线程使用锁就可以获取/设置锁，其他线程获取/设置时就失败并等待
2. 逻辑过期：不直接设置Redis缓存的过期时间，而是通过在缓存数据中添加逻辑过期时间，如果发现过期了就开一个新的线程来重建，原本线程以及其他访问线程都直接返回旧数据

![[d3cb7ce6361a29eabd7d4448e44b91a.jpg]]

![[37863ca68adcacc3a7ef386c6b82baa.jpg]]![[ebe355db7343bc0fff72845811d330e.jpg]]

![[35cbc8c194261a80c253de7842e4b81.jpg]]![[2e53a463393d03197716a04d9c0a56b.jpg]]

# 三、秒杀业务

## 1. 分布式锁


## 2. 消息队列
