# 一、数据结构

## 1. 动态字符串 SDS

一个可扩容的字符数组来模拟可增长的字符串

### 数据结构

数据不同长度对应的结构体也不同，所以需要用flags标识数据的最大长度

![[89702def4766dfac18f09fd031e7353.jpg]]

### 扩容

![[1a797f360b70dd0b55fc2010e731f44.jpg]]

## 2. IntSet

一个可扩容的、有序的、值唯一的整数数组来模拟set集合

### 数据结构

![[bb7a9752625eb5efcf6f0abf0ba297c.jpg]]

字节数组不代表存储的值大小就是一个字节，其只是用来作为存储值的一段空间，存储的值的大小是通过 `encoding` 来决定的，值会存储在字节数组中（一个值可能占多个字节）

![[f4c2b80debfc2c5ce692f0e7decc1a9.jpg]]

### 升级扩大编码

![[ee53f2da822d48dcfbee1b630a7feb9.jpg]]

新增的值会保证有序：通过二分查找找到适当的位置，然后将后面的值移动，最后插入新值

![[Pasted image 20240306112932.png]]

## 3. Dict

数组+单向链表 来模拟哈希表

### 数据结构

![[b20e42c98eb1484a0f8c771cfc29156.jpg]]![[89ebeaa5012487a7feb528da004c98c.jpg]]![[1e96b2db70091e1bd1d492c62cfddd8.jpg]]

### 扩容（找一个大于等于当前使用量+1的 $2^n$ 的容量）

![[72aa51f376566b6c4729194bf3c3d19.jpg]]

### 收缩（找一个大于等于当前使用量的 $2^n$ 的容量）

![[061a64ab4d6e1bd09ca24fb1d56abc8.jpg]]

### rehash

新分配了一个HashTable给 `dict.ht[1]`，之后需要将之前哈希表中所有的节点都重新映射到新的哈希表中，然后将新的哈希表放到 `dict.ht[0]` 中

![[28f84e64a3ec10fc4ca5f2c33c02083.jpg]]

![[a0e843d5727c781a82853f849009a68.jpg]]![[1660783261283db6ac61c3dbedcf6ec.jpg]]![[7aeae6b3c8f9b5da1656563231bb58b.jpg]]

#### 渐进式rehash

如果HashTable过大，直接进行rehash会导致阻塞时间过长，而渐进式rehash就是在每次增删改查的时候rehash旧哈希表的一个下标的链表中所有节点：

* 增：直接在新的哈希表中增
* 删改查：需要搜索两个哈希表看在哪一个哈希表中进行操作（在计算了第一个哈希表的哈希值后可以直接判断该下标是否在当前已rehash的下标之前，如果在之前就表明节点在新的哈希表中）

![[5a9166153a2bfdfee713ac8f0516d48.jpg]]

![[Pasted image 20240306150226.png]]

## 4. ZipList

通过类似数组的方式（每个节点包含内容和其他信息）来模拟双向链表，但是是**连续内存分布**，也就是不能O(1)插入中间节点，只能O(1)插入首尾节点（同时如果一次性内存分配过多会导致效率低下，所以大小不宜过大）

因为Redis是存储在内存中的，内存很重要，而ZipList解决了传统双向链表的**内存占用**问题（每个节点包含前后指针——8个字节），但是对于**增删查改非末尾节点的操作需要额外的时间**（需要遍历查找，同时还可能需要拷贝部分数组）

### 数据结构

![[9226933da0cdeeee3f4c79ba48459a8.jpg]]![[9f12f70da040387cae6eb89d5fc26e7.jpg]]![[7f3e1a001c663c348335dcfb77e21d7.jpg]]

![[1fb7dc586ede983c3d25e54962df8e4.jpg]]![[a81ca571839653f121fee208949e0be.jpg]]

### 连锁更新

在**多个连续的长度为255字节少一点的节点情况下**，当使用前插法时，如果新节点长度超过255，那么原本的第一个节点就需要修改记录的前面长度从1字节变成5字节，如果修改后该节点长度也超过255，就会导致后面的节点也要修改记录前面长度的那个属性值，一直连锁下取

![[664175533fbea059910a2773fc3ca5d.jpg]]

![[Pasted image 20240306153619.png]]

## 5. QuickList

双向链表，每个节点都是ZipList

### 数据结构

![[5c7b06f6e21864bc33c70442da3f81f.jpg]]![[01e58cc30e6fb9ff0bc3a458456f188.jpg]]![[be8a6112561c83affb139f235acda92.jpg]]

![[Pasted image 20240306154642.png]]

## 6. SkipList 跳表

双向链表，每个节点包含前后指针，其中后指针可能有多个（跳跃），结点的值是[[#1. 动态字符串 SDS|sds]]，每个节点都有得分score来排序

### 数据结构

![[8c00ca41fc8370ccda63e7dd611fc53.jpg]]![[b3f38c645a58c2f615626ce26be3e52.jpg]]![[fb8835feb8d5189a9569af62b88012c.jpg]]

![[Pasted image 20240306155904.png]]

## 7. RedisObject

Redis中的所有键/值都会被封装成`RedisObject`结构（也称为Redis对象），结构的大小为16字节

Redis每个数据库中通过键查找到的结果都是 `RedisObject` 对象

![[58db0543a09dc277d48fd2c9158416d.jpg]]

### 编码方式

RedisObject会根据对象类型不同采用不同的编码方式

![[9f71c3a0423b611b5e28016084dbdd3.jpg]]![[4bb0ac3da455fc3dfe346dc53d5e364.jpg]]

# 二、五种基本数据类型

## 1. String

有三种编码方式 -> 三种不同存储方式：

1. RAW：RedisObject和SDS各自分配内存
2. EMBSTR：如果SDS字符串长度小于等于44字节可以一起分配内存
	* RedisObject（16字节） + SDS (1+1+1+44+1=48字节) = 64字节，刚好内存分配的一块
3. INT：分配的是整数且小于等于long长度（8字节），直接在RedisObject的void* 指针中存储二进制整数值

`object encoding <对象>`：查看对象编码方式

![[069f5a69720e77435a9a235189e2efc 1.jpg]]![[282f12715d1c5fa43de2cddb591a92d.jpg]]![[40b8158abcf9149bb05b19bbc098e87.jpg]]

![[57c716216bcd482175b81fcbdc19e38.jpg]]

## 2. List

由于List只能够操作首尾，所以可以用ZipList / **QuickList**实现（节省内存）

![[7b9c2312e35225a8eabae9c65cb153a.jpg]]![[d871b7ff3bc30e996bde1d44c574929.jpg]]

## 3. Set

1. 由于Set集合中经常需要查询元素是否存在，所以一般的数组/链表结构不适合，而哈希表能够实现**快速查询**，所以用**Dict**实现（key存储元素，value为null）
	* 但是哈希表中每个节点都需要单独分配内存，且需要指针来构建链表，消耗内存大
2. 如果存储的数据都为**整数**，且元素数量不超过一定值就可以用 **IntSet** 来节省内存
	* 但是数组类型查找元素**较耗时**
	* 如果在IntSet类型下插入字符串类型键 或 元素数量过多，会**转化成 Dict**

![[d773db3d1b20ac31f3b0f5c606115ef.jpg]]![[43df962257d0026016c15cd3b391b75.jpg]]

### IntSet转为Dict

![[85d6a8125f266c5bf0fd37c1343a8a0.jpg]]![[2e69257821bfa4284da266b698275c9.jpg]]

## 4. ZSet

1. 结构 `zset`，里面**包含了 `SkipList` 和 `Dict`**
	1. `SkipList`：键值存储、可排序；但是查找键需要遍历所有节点
	2. `Dict`：键值存储、查找快速；但是无法排序
	3. 优点：可排序、查询快
	4. 缺点：耗内存、增删耗时
2. 元素数量不多时，使用 `ZipList` 节省内存
	1. 将score和element分为两个entry紧挨存储
	2. 手动根据score排序

![[5dc319d6ee54dbe4510cbae589b97f4.jpg]]![[ebfe4fa1e24e300d14b081015f2c3e5.jpg]]

![[b74036369a539ffecfca794ba1dd6b4.jpg]]![[5d26922e9ee9de28fe9f268e8431049.jpg]]

### ZipList转为SkipList+Dict

![[908e20d1bf7c1608454ad97dac165a6.jpg]]

## 5. Hash

与ZSet类似，不过不用排序，所以只需要将ZSet中的 `SkipList` 去掉即可

1. 默认用 `ZipList` 节省内存
	1. 将键值分为两个entry相邻存储
2. 数据量较大时用 `Dict`

![[719d04e83e183ecafd62b522f9d78fb.jpg]]![[2d7a370893e669024e419dc5b192ac7.jpg]]![[95cad35743de4fb84c84ad750ec3ad8.jpg]]

### ZipList转为Dict

![[13d8ff81d8ae31b0d4054dc814bbafc.jpg]]![[217c2537e36d844db0d655a87ee5da3.jpg]]

# 三、网络模型

## 1. 阻塞IO

RunableOS用的就是阻塞IO

![[406637e25955c286828fa8e79a839e5.jpg]]

## 2. 非阻塞IO

![[664f5276cd79a9b14860ff85dded5f3.jpg]]

## 3. IO多路复用

类似于阻塞IO，但是一次性能够监听多个fd来读取多个文件内容

![[240ab18c3555d1bf103d1d0336c2953.jpg]]![[e2c9a4b6c873832f3e74f50c1a26594.jpg]]

### 1. select

![[e62e83feb4b83c3c1a057ae4d79c0e6.jpg]]

### 2. poll

改进了select的固定文件数，采用数组理论可以无上限

![[39832e4d30de723f07d9ffa46625753.jpg]]

### 3. epoll

![[41e324830e5fcb5be581213895402df.jpg]]

#### 事件通知机制

![[8894a7b4a7c08a2d68ca2fd022ecad5.jpg]]

#### Web流程

服务器通过epoll方式读取请求数据，创建 `serverSocket` 加入到epoll的红黑树中监听是否有用户请求

![[3b456fc28d0ce692875eb44afb3c9e7.jpg]]

### 总结

![[Pasted image 20240307091859.png]]

## 4. 信号驱动IO

数据就绪了通知**用户进程调用函数来将数据从内核空间拷贝到用户空间**（通过信号来通知）

![[c99940b71499512fef844a94d39ea97.jpg]]

缺点：一有数据拷贝完毕就需要通过信号机制发送给用户，如果信号过多会导致信号处理函数不能及时处理信号，使得信号队列溢出；且信号交互效率低

## 5. 异步IO

数据就绪了也不用通知用户进程，而是在**内核中自动拷贝数据到用户空间**后再通知用户进程处理（也是通过信号来通知）

![[08a1023a776abdab09a4c3a441a2b5f.jpg]]

缺点：内核拷贝数据到用户空间时间长，如果有多个数据请求会导致内核需要花费大量时间来拷贝数据

### 同步和异步

![[7dd87940d7d3c917e6b9c74f0b2330a.jpg]]

## 6. Redis的网络模型

Redis相当于一个程序放在内存当中执行，它数据库是放在内存中的，同时也作为一个服务器监听某个端口发送的请求（创建`ServerSocket`得到其fd），并通过多路复用（epoll）来进行数据的读写（类似 [[#Web流程]]）

1. 类似 `epoll_create` 在内核中创建 `eventpoll` 实例（红黑树、链表）
2. 监听TCP端口，创建 `ServerSocket` 并得到其fd
3. 将 `ServerSocket` 的fd添加到红黑树中监听读事件（读取客户端连接）
	* 如果客户端发送连接请求，`ServerSocket`中就会有对应数据，然后接收得到客户端 `socket` 对应的fd，将其注册加入到红黑树中监听
4. 循环等待事件，类似 `epoll_wait`，如果客户端 `socket` 发送请求就执行对应的处理（读写数据）
	* 每次循环的开始都会遍历Redis缓冲区队列中等待的client，为它们对应的客户端都添加写处理器到fd中，同时
	* 客户端请求读取数据（先触发读事件，再触发写事件）：
		1. 客户端fd有读请求，对应的处理器将请求写到Redis缓冲区，解析请求，执行命令，将结果写到Redis缓冲区，并**放到缓冲区队列中等待客户端读取**
		2. 如果客户端已经注册写处理器，就会执行对应的写处理器中的函数来将队列中数据**写回客户端的socket中**

![[ce9352a1b7406f4a2f316c1e24fde98 1.jpg]]

![[ec930356d9ab57a3517027a12ae53e5.jpg]]![[e63e091d05ccfea65de454828e50f22.jpg]]

### 单线程与多线程

![[152e261e583f6ec61dfc3f25de6344f.jpg]]

* 单线程部分：IO多路复用、事件派发
* 多线程部分：
	1. 客户端请求命令的解析、执行（Redis操作）
	2. 从内核缓冲区读取客户端数据到内存缓冲区中（写请求）
	3. 将内存缓冲区中数据写入内核缓冲区中（读请求）

![[28d3da0d6c2b4352ed1ed0a60818aa8.jpg]]

# 四、Redis通信协议

客户端发送命令、服务端响应结果，它们的格式都必须有一个**规范**，这个规范就是通信协议

## 1. RESP协议

![[3384c68dfff449d303fe7c67b99e632.jpg]]

![[b911e059ad6c5760c29609db25257b6.jpg]]

# 五、Redis内存策略

Redis数据库本身是通过一个 `redisDb` 的数据结构存储的，主要用到了 `Dict` 来进行键值存储

* Redis利用**虚拟内存**技术，允许Redis在数据量超过物理内存容量时，将一部分不经常使用的数据存储到硬盘上，以释放物理内存空间；当需要访问已经被交换到硬盘上的页面时，Redis会将其重新读取到内存中，这样就可以访问其中的数据了
* 同时Redis也提供了持久化选项，能够将数据存储到磁盘中

## 1. 过期策略

![[6d512e130d482252c5b65ad85192596.jpg]]

![[Pasted image 20240307113452.png]]

### 1. 惰性删除

当访问的时候先检查是否过期，过期再删除

### 2. 周期删除

1. 设置定时任务周期性抽样部分key，如果过期了就删除（不是真的定时）
	1. 初始化时就进行清除，并且返回周期时间
	2. 之后每次循环处理事件（网络模型中的循环事件）后都会检查时间是否到了，到了就进行清除，并重新设置周期时间
2. 每次循环处理事件之前都调用 `beforeSleep()` 清除过期key（快速）

![[fdeb41c851154228cb5d46aa45b1ad0.jpg]]![[d83a88d64f5c504da0e1c2fe7ef2b7e.jpg]]

### 总结

![[Pasted image 20240307113537.png]]

## 2. 淘汰策略

如果很多对象都没有设置过期时间，会导致内存占用过多，所以需要内存淘汰策略**主动删除部分key**（会对所有数据库及进行选择来淘汰）

执行时期：**客户端命令处理之前**进行内存淘汰

![[5bc6294aaaa8a51018f5797094b8eac.jpg]]

淘汰策略：

![[33ae40336ff7aa7213e4f69af797c4b.jpg]]

LRU和LFU的支持：

![[a6d1bb4a82ba9817eda03564a093ba9.jpg]]

### 执行过程

![[602c16ffea78141e837b7b95c6689d4.jpg]]