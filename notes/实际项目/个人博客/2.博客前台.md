# 一、热门文章展示

## 1. 统一响应结果

通用模块中统一响应结果 `ResponseResult` 放在 `domain/` 文件夹下

```java
package com.sj.domain;  
  
import com.fasterxml.jackson.annotation.JsonInclude;  
import com.sj.domain.enums.AppHttpCodeEnum;  
  
import java.io.Serializable;  
  
/**  
 * 响应的结果  
 * @param <T>  
 */  
@JsonInclude(JsonInclude.Include.NON_NULL)  
public class ResponseResult<T> implements Serializable {  
    private Integer code;  
    private String msg;  
    private T data;  
  
    public ResponseResult() {  
        this.code = AppHttpCodeEnum.SUCCESS.getCode();  
        this.msg = AppHttpCodeEnum.SUCCESS.getMsg();  
    }  
  
    public ResponseResult(Integer code, T data) {  
        this.code = code;  
        this.data = data;  
    }  
  
    public ResponseResult(Integer code, String msg, T data) {  
        this.code = code;  
        this.msg = msg;  
        this.data = data;  
    }  
  
    public ResponseResult(Integer code, String msg) {  
        this.code = code;  
        this.msg = msg;  
    }  
  
    public static ResponseResult errorResult(int code, String msg) {  
        ResponseResult result = new ResponseResult();  
        return result.error(code, msg);  
    }  
    public static ResponseResult okResult() {  
        ResponseResult result = new ResponseResult();  
        return result;  
    }  
    public static ResponseResult okResult(int code, String msg) {  
        ResponseResult result = new ResponseResult();  
        return result.ok(code, null, msg);  
    }  
  
    public static ResponseResult okResult(Object data) {  
        ResponseResult result = setAppHttpCodeEnum(AppHttpCodeEnum.SUCCESS, AppHttpCodeEnum.SUCCESS.getMsg());  
        if(data!=null) {  
            result.setData(data);  
        }  
        return result;  
    }  
  
    public static ResponseResult errorResult(AppHttpCodeEnum enums){  
        return setAppHttpCodeEnum(enums,enums.getMsg());  
    }  
  
    public static ResponseResult errorResult(AppHttpCodeEnum enums, String msg){  
        return setAppHttpCodeEnum(enums,msg);  
    }  
  
    public static ResponseResult setAppHttpCodeEnum(AppHttpCodeEnum enums){  
        return okResult(enums.getCode(),enums.getMsg());  
    }  
  
    private static ResponseResult setAppHttpCodeEnum(AppHttpCodeEnum enums, String msg){  
        return okResult(enums.getCode(),msg);  
    }  
  
    public ResponseResult<?> error(Integer code, String msg) {  
        this.code = code;  
        this.msg = msg;  
        return this;  
    }  
  
    public ResponseResult<?> ok(Integer code, T data) {  
        this.code = code;  
        this.data = data;  
        return this;  
    }  
  
    public ResponseResult<?> ok(Integer code, T data, String msg) {  
        this.code = code;  
        this.data = data;  
        this.msg = msg;  
        return this;  
    }  
  
    public ResponseResult<?> ok(T data) {  
        this.data = data;  
        return this;  
    }  
  
    public Integer getCode() {  
        return code;  
    }  
  
    public void setCode(Integer code) {  
        this.code = code;  
    }  
  
    public String getMsg() {  
        return msg;  
    }  
  
    public void setMsg(String msg) {  
        this.msg = msg;  
    }  
  
    public T getData() {  
        return data;  
    }  
  
    public void setData(T data) {  
        this.data = data;  
    }  
  
}
```

其中用到的响应码枚举 `AppHttpCodeEnum` 放在 `enums/` 文件夹下

```java
package com.sj.domain.enums;  
  
/**  
 * 枚举所有响应码  
 */  
public enum AppHttpCodeEnum {  
    // 成功  
    SUCCESS(200,"操作成功"),  
    // 登录  
    NEED_LOGIN(401,"需要登录后操作"),  
    NO_OPERATOR_AUTH(403,"无权限操作"),  
    SYSTEM_ERROR(500,"出现错误"),  
    USERNAME_EXIST(501,"用户名已存在"),  
    PHONENUMBER_EXIST(502,"手机号已存在"), EMAIL_EXIST(503, "邮箱已存在"),  
    REQUIRE_USERNAME(504, "必需填写用户名"),  
    LOGIN_ERROR(505,"用户名或密码错误");  
    int code;  
    String msg;  
  
    AppHttpCodeEnum(int code, String errorMessage){  
        this.code = code;  
        this.msg = errorMessage;  
    }  
  
    public int getCode() {  
        return code;  
    }  
  
    public String getMsg() {  
        return msg;  
    }  
}
```

## 2. 查询热门文章

控制类 `ArticleController`

```java
/**  
 * 查询热门文章  
 * @return  
 */  
@GetMapping("/hotArticleList")  
public ResponseResult hotArticleList() {  
    return articleService.hotArticleList();  
}
```

业务类 `ArticleServiceImpl`

```java
/**  
 * 查询热门文章  
 * @return  
 */  
@Override  
public ResponseResult hotArticleList() {  
    // 条件：正式文章、热度降序排序、前10篇  
    LambdaQueryWrapper<Article> queryWrapper = new LambdaQueryWrapper<>();  
    queryWrapper.eq(Article::getStatus, 0);  
    queryWrapper.orderByDesc(Article::getViewCount);  
  
    Page<Article> pageInfo = new Page<>(1, 10);  
    this.page(pageInfo, queryWrapper);  
    List<Article> articles = pageInfo.getRecords();  
  
    return ResponseResult.okResult(articles);  
}
```

## 3. 优化

### 1. 系统常量使用

对于一些字面量直接使用不好理解，通过常量形式使用更易理解：这里在通用模块 `sj-framework` 中的 `constants/SystemConstants` 内定义文章状态常量，然后修改业务类 `ArticleServiceImpl` 中对应的使用

```java
/**  
 * 系统用到的常量  
 */  
public class SystemConstants  
{  
    /**  
     *  文章是草稿  
     */  
    public static final int ARTICLE_STATUS_DRAFT = 1;  
    /**  
     *  文章是正常分布状态  
     */  
    public static final int ARTICLE_STATUS_NORMAL = 0;  
  
}
```

### 2. Bean拷贝工具类

因为拷贝对象/列表很常用，所以在通用模块的 `utils/BeanCopyUtils` 中定义一个工具类

```java
public class BeanCopyUtils {  
  
    private BeanCopyUtils() {}  
  
    /**  
     * 拷贝单个对象  
     * @param source  
     * @param clazz  
     * @return  
     * @param <V>  
     */  
    public static <V> V copyBean(Object source, Class<V> clazz) {  
        V result = null;  
        try {  
            result = clazz.newInstance();  
            // bean拷贝  
            BeanUtils.copyProperties(source, result);  
        } catch (Exception e) {  
            e.printStackTrace();  
        }  
        return result;  
    }  
  
    /**  
     * 拷贝整个列表  
     * @param list  
     * @param clazz  
     * @return  
     * @param <V>  
     */  
    public static <O, V> List<V> copyBeanList(List<O> list, Class<V> clazz) {  
        return list.stream()  
                .map(item -> copyBean(item, clazz))  
                .collect(Collectors.toList());  
    }  
}
```

最终的 `ArticleServiceImpl` 为：

```java
/**  
 * 查询热门文章  
 * @return  
 */  
@Override  
public ResponseResult hotArticleList() {  
    // 1.根据条件查询：正式文章、热度降序排序、前10篇  
    LambdaQueryWrapper<Article> queryWrapper = new LambdaQueryWrapper<>();  
    queryWrapper.eq(Article::getStatus, SystemConstants.ARTICLE_STATUS_NORMAL);  
    queryWrapper.orderByDesc(Article::getViewCount);  
  
    Page<Article> pageInfo = new Page<>(1, 10);  
    this.page(pageInfo, queryWrapper);  
    List<Article> articles = pageInfo.getRecords();  
  
    // 2.构造vo返回  
    /*  
    List<HotArticleVo> hotArticleVos = articles.stream().map((item) -> {        HotArticleVo hotArticleVo = new HotArticleVo();        BeanUtils.copyProperties(item, hotArticleVo);        return hotArticleVo;    }).collect(Collectors.toList());    */    List<HotArticleVo> hotArticleVos = BeanCopyUtils.copyBeanList(articles, HotArticleVo.class);  
  
    return ResponseResult.okResult(hotArticleVos);  
}
```

# 二、类别展示

页面需要展示所有分类列表

控制类 `CategoryController`

```java
@GetMapping("/getCategoryList")  
public ResponseResult getCategoryList() {  
    return categoryService.getCategoryList();  
}
```

业务类 `CategoryServiceImpl`

```java
@Override  
public ResponseResult getCategoryList() {  
    // 1.查询正常状态的文章列表  
    LambdaQueryWrapper<Article> articleWrapper = new LambdaQueryWrapper<>();  
    articleWrapper.eq(Article::getStatus, SystemConstants.ARTICLE_STATUS_NORMAL);  
    List<Article> articleList = articleService.list(articleWrapper);  
  
    // 2.得到类别ids，并且用set去重  
    Set<Long> ids = articleList.stream().map(item -> item.getCategoryId()).collect(Collectors.toSet());  
  
    // 3.查询类别表  
    List<Category> categoryList = this.listByIds(ids);  
  
    // 4.保留正常状态的类别  
    categoryList = categoryList.stream()  
            .filter(item -> SystemConstants.STATUS_NORMAL.equals(item.getStatus()))  
            .collect(Collectors.toList());  
  
    // 5.返回vo  
    List<CategoryVo> categoryVoList = BeanCopyUtils.copyBeanList(categoryList, CategoryVo.class);  
  
    return ResponseResult.okResult(categoryVoList);  
}
```

# 三、分页查询文章列表

查询对应类别下面的文章

1. `config/MybatisPlusConfig` 下支持mp分页配置

```java
//分页的拦截器配置，MybatisPlus  
@Configuration  
public class MybatisPlusConfig {  
  
    /**  
     * 3.4.0之后版本  
     * @return  
     */  
    @Bean  
    public MybatisPlusInterceptor mybatisPlusInterceptor(){  
        MybatisPlusInterceptor mybatisPlusInterceptor = new MybatisPlusInterceptor();  
        mybatisPlusInterceptor.addInnerInterceptor(new PaginationInnerInterceptor());  
        return mybatisPlusInterceptor;  
    }  
}
```

2. `config/WebConfig` 下支持fastjson中返回结果Data日期转换格式

```java
@Bean//使用@Bean注入fastJsonHttpMessageConvert。fastjson配置  
//利用fastjson进行转换  
public HttpMessageConverter fastJsonHttpMessageConverters() {  
    //1.需要定义一个Convert转换消息的对象  
    FastJsonHttpMessageConverter fastConverter = new FastJsonHttpMessageConverter();  
    FastJsonConfig fastJsonConfig = new FastJsonConfig();  
    fastJsonConfig.setSerializerFeatures(SerializerFeature.PrettyFormat);  
    fastJsonConfig.setDateFormat("yyyy-MM-dd HH:mm:ss"); //日期转换格式  
  
    SerializeConfig.globalInstance.put(Long.class, ToStringSerializer.instance);  
  
    fastJsonConfig.setSerializeConfig(SerializeConfig.globalInstance);  
    fastConverter.setFastJsonConfig(fastJsonConfig);  
    HttpMessageConverter<?> converter = fastConverter;  
    return converter;  
}  
  
@Override  
public void configureMessageConverters(List<HttpMessageConverter<?>> converters) {  
    converters.add(fastJsonHttpMessageConverters());  
}
```

3. 控制类 `ArticleController` 

```java
/**  
 * 分页查询文章  
 * @param pageNum  
 * @param pageSize  
 * @param categoryId  
 * @return  
 */  
@GetMapping("/articleList")  
public ResponseResult articleList(Integer pageNum, Integer pageSize, Long categoryId) {  
    return articleService.articleList(pageNum, pageSize, categoryId);  
}
```

4. 业务类 `ArticleServiceImpl`

```java
@Override  
public ResponseResult articleList(Integer pageNum, Integer pageSize, Long categoryId) {  
    // 1.分页  
    Page<Article> pageInfo = new Page<>(pageNum, pageSize);  
  
    // 2.条件查询：判断是否需要看类别、正式发布的文章、热度降序  
    LambdaQueryWrapper<Article> queryWrapper = new LambdaQueryWrapper<>();  
    queryWrapper.eq(categoryId != null && categoryId > 0, Article::getCategoryId, categoryId);  
    queryWrapper.eq(Article::getStatus, SystemConstants.ARTICLE_STATUS_NORMAL);  
    queryWrapper.orderByDesc(Article::getIsTop).orderByDesc(Article::getViewCount);  
  
    this.page(pageInfo, queryWrapper);  
    List<Article> articleList = pageInfo.getRecords();  
  
    // 3.查询categoryName来填充  
    articleList.forEach(item ->  
        item.setCategoryName(categoryService.getById(item.getCategoryId()).getName()));  
  
    // 4.封装查询结果  
    List<ArticleListVo> articleListVoList = BeanCopyUtils.copyBeanList(articleList, ArticleListVo.class);  
    PageVo pageVo = new PageVo(articleListVoList, pageInfo.getTotal());  
    return ResponseResult.okResult(pageVo);  
}
```

其中返回的结果中data为 `PageVo`，里面封装了列表 `ArticleList`（返回的结果要有所有的Vo中的值才能显示，所以构造数据的时候要填充好）

# 四、文章详细信息

1. 控制类 `ArticleController`

```java
/**  
 * 获取文章详细信息  
 * @param id  
 * @return  
 */  
@GetMapping("/{id}")  
public ResponseResult getArticleDetail(@PathVariable("id") Long id) {  
    return articleService.getArticleDetail(id);  
}
```

2. 业务类 `ArticleServiceImpl`

```java
@Override  
public ResponseResult getArticleDetail(Long id) {  
    // 1.根据id查找文章  
    Article article = this.getById(id);  
    if (article == null) {  
        return ResponseResult.errorResult(AppHttpCodeEnum.SYSTEM_ERROR, "无法查到该文章");  
    }  
  
    // 2.填充类别名称字段  
    Category category = categoryService.getById(article.getCategoryId());  
    if (category != null) {  
        article.setCategoryName(category.getName());  
    }  
  
    // 3.返回  
    return ResponseResult.okResult(article);  
}
```

# 五、友链

友链页面显示所有审核通过的友链

1. 控制类 `LinkController`

```java
/**  
 * 查询所有审核通过的友链  
 * @return  
 */  
@GetMapping("/getAllLink")  
public ResponseResult getAllLink() {  
    return linkService.getAllLink();  
}
```

2. 业务类 `LinkServiceImpl`

```java
@Override  
public ResponseResult getAllLink() {  
    // 1.查询所有审核通过的友链  
    LambdaQueryWrapper<Link> queryWrapper = new LambdaQueryWrapper<>();  
    queryWrapper.eq(Link::getStatus, SystemConstants.LINK_STATUS_NORMAL);  
    List<Link> linkList = this.list(queryWrapper);  
  
    // 2.封装成LinkVo返回  
    List<LinkVo> linkVos = BeanCopyUtils.copyBeanList(linkList, LinkVo.class);  
    return ResponseResult.okResult(linkVos);  
}
```

# 六、登录功能

## 1. 前提工作

1. 公共模块引入 SpringSecurity 依赖

```xml
<!--SpringSecurity启动器-->  
<dependency>  
    <groupId>org.springframework.boot</groupId>  
    <artifactId>spring-boot-starter-security</artifactId>  
</dependency>
```

2. 导入资料中的配置文件和工具类到公共模块中
	1. 配置文件：`FastJsonRedisSerializer.java, RedisConfig.java`
	2. 工具类：`JwtUtil.java, RedisCache.java, WebUtils.java`

下面的步骤大纲参考[[认证&授权#二、认证|认证的登录校验部分]]

## 2. 登录实现

1. 在前端模块 `sj-blog` 中添加配置文件 `SecurityConfig` 
	1. 暴露 `AuthenticationManager` bean对象来使用
	2. 实现 `passwordEncoder` 来暴露该encoder来对密码加密
	3. 配置不需要认证的登录操作，以及允许跨域

```java
@Configuration  
public class SecurityConfig extends WebSecurityConfigurerAdapter {  
  
    @Override  
    @Bean    
    public AuthenticationManager authenticationManagerBean() throws Exception {  
        return super.authenticationManagerBean();  
    }  
  
    @Bean  
    public PasswordEncoder passwordEncoder() {  
        return new BCryptPasswordEncoder();  
    }  
  
    @Override  
    protected void configure(HttpSecurity http) throws Exception {  
        http  
                //关闭csrf  
                .csrf().disable()  
                //不通过Session获取SecurityContext  
                .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS)  
                .and()  
                .authorizeRequests()  
                // 对于登录接口 允许匿名访问  
                .antMatchers("/login").anonymous()  
                // 除上面外的所有请求全部不需要认证即可访问  
                .anyRequest().permitAll();  
  
  
        http.logout().disable();  
        //允许跨域  
        http.cors();  
    }  
}
```

2. 创建 `UserDetailsServiceImpl` 实现 `UserDetailsService`来查询用户对应的密码并返回

```java
@Service  
public class UserDetailsServiceImpl implements UserDetailsService {  
  
    @Autowired  
    private UserMapper userMapper;  
  
    @Override  
    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {  
        // 1.根据用户名查询用户信息  
        LambdaQueryWrapper<User> queryWrapper = new LambdaQueryWrapper<>();  
        queryWrapper.eq(User::getUserName, username);  
        User user = userMapper.selectOne(queryWrapper);  
  
        // 2.判断是否查到用户，没查到就抛出异常  
        if (Objects.isNull(user)) {  
            throw new RuntimeException("用户不存在");  
        }  
  
        // 3.返回用户信息  
        // TODO 查询权限信息封装  
        return new LoginUser(user);  
    }  
}
```

2.1 创建类 `LoginUser` 实现接口 `UserDetails` 来封装User对象

```java
@Data  
@NoArgsConstructor  
@AllArgsConstructor  
public class LoginUser implements UserDetails {  
  
    private User user;  
  
    @Override  
    public Collection<? extends GrantedAuthority> getAuthorities() {  
        return null;  
    }  
  
    @Override  
    public String getPassword() {  
        return user.getPassword();  
    }  
  
    @Override  
    public String getUsername() {  
        return user.getUserName();  
    }  
  
    @Override  
    public boolean isAccountNonExpired() {  
        return true;  
    }  
  
    @Override  
    public boolean isAccountNonLocked() {  
        return true;  
    }  
  
    @Override  
    public boolean isCredentialsNonExpired() {  
        return true;  
    }  
  
    @Override  
    public boolean isEnabled() {  
        return true;  
    }  
}
```

3. 创建 `BlogLoginServiceImpl` 实现 `BlogLoginService`
	1. 用户名和密码认证
	2. 判断是否认证通过
	3. 获取userid，生成token（也就是jwt令牌）
	4. 将用户信息存入redis中
	5. 返回token及相关用户信息到前端

```java
@Service  
public class BlogLoginServiceImpl implements BlogLoginService {  
  
    @Autowired  
    private AuthenticationManager authenticationManager;  
  
    @Autowired  
    private RedisCache redisCache;  
  
    @Override  
    public ResponseResult login(User user) {  
        // 1.用户名和密码认证  
        UsernamePasswordAuthenticationToken authenticationToken =  
                new UsernamePasswordAuthenticationToken(user.getUserName(), user.getPassword());  
        Authentication authenticate = authenticationManager.authenticate(authenticationToken);  
  
        // 2.判断是否认证通过  
        if (Objects.isNull(authenticate)) {  
            throw new RuntimeException("用户名或密码错误");  
        }  
  
        // 3.获取userid，生成token  
        LoginUser loginUser = (LoginUser) authenticate.getPrincipal();  
        String userId = loginUser.getUser().getId().toString();  
        String jwt = JwtUtil.createJWT(userId);  
  
        // 4.把用户信息存入redis  
        redisCache.setCacheObject("blogLogin:"+userId, loginUser);  
  
        // 5.把token和userinfo封装并返回  
        UserInfoVo userInfoVo = BeanCopyUtils.copyBean(loginUser.getUser(), UserInfoVo.class);  
        BlogUserLoginVo blogUserLoginVo = new BlogUserLoginVo(jwt, userInfoVo);  
        return ResponseResult.okResult(blogUserLoginVo);  
    }  
}
```

3.1 用到的实体类Vo

```java
// 1.前端接受结果
@Data  
@NoArgsConstructor  
@AllArgsConstructor  
public class BlogUserLoginVo {  
  
    private String token;  
    private UserInfoVo userInfo;  
}
```

```java
// 2.进一步封装结果
@Data  
@NoArgsConstructor  
@AllArgsConstructor  
public class UserInfoVo {  
  
    private Long id;  
    private String nickName;  
    private String avatar;  
    private String sex;  
    private String email;  
}
```

## 3. 校验实现

1. 实现登录校验过滤器 `JwtAuthenticationFilter` 继承 `OncePerRequestFilter`
	* 定义**jwt认证过滤器**（需要放行 login 登录页面，并且需要配置在 `UsernamePasswordAuthenticationFilter` 过滤器之前）
		1. 获取token
		2. 解析token并获取其中的userid
		3. 从redis中获取用户信息和权限信息
		4. 将用户信息和权限信息都封装到 `Authentication` 中，**存入 `SecurityContextHolder`**（其他过滤器从中获取用户信息）

在前台模块中实现jwt过滤器：

```java
@Component  
public class JwtAuthenticationTokenFilter extends OncePerRequestFilter {  
  
    @Autowired  
    private RedisCache redisCache;  
  
    @Override  
    protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) throws ServletException, IOException {  
        // 1.获取请求头中的token  
        String token = request.getHeader("token");  
        if (!StringUtils.hasText(token)) {  
            // 没有token对应的内容，放行到后面的过滤器中处理  
            filterChain.doFilter(request, response);  
            return;  
        }  
  
        // 2.解析获取userid  
        Claims claims = null;  
        try {  
            claims = JwtUtil.parseJWT(token);  
        } catch (Exception e) {  
            e.printStackTrace();  
            // token非法/超时，需要重新登录  
            ResponseResult result = ResponseResult.errorResult(AppHttpCodeEnum.NEED_LOGIN);  
            WebUtils.renderString(response, JSON.toJSONString(result));  
            return;  
        }  
        String userId = claims.getSubject();  
  
        // 3.从redis中获取用户信息  
        LoginUser loginUser = redisCache.getCacheObject("blogLogin:" + userId);  
        // 4.如果获取不到代表登陆过期/退出登录，重新登录  
        if (Objects.isNull(loginUser)) {  
            ResponseResult result = ResponseResult.errorResult(AppHttpCodeEnum.NEED_LOGIN);  
            WebUtils.renderString(response, JSON.toJSONString(result));  
            return;  
        }  
  
        // 5.存入SecurityContextHolder  
        UsernamePasswordAuthenticationToken authenticationToken = new UsernamePasswordAuthenticationToken(loginUser, null, null);  
        SecurityContextHolder.getContext().setAuthentication(authenticationToken);  
  
        filterChain.doFilter(request, response);  
    }  
}
```

配置类 `SecurityConfig` 里面配置该过滤器

```java
    @Override  
    protected void configure(HttpSecurity http) throws Exception {  
        http  
                //关闭csrf  
                .csrf().disable()  
                //不通过Session获取SecurityContext  
                .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS)  
                .and()  
                .authorizeRequests()  
                // 对于登录接口 允许匿名访问  
                .antMatchers("/login").anonymous()  
//                .antMatchers("/link/getAllLink").authenticated()  
                // 除上面外的所有请求全部不需要认证即可访问  
                .anyRequest().permitAll();  
  
  
        http.logout().disable();  
  
        //把jwtAuthenticationTokenFilter添加到SpringSecurity过滤器链中  
        http.addFilterBefore(jwtAuthenticationTokenFilter, UsernamePasswordAuthenticationFilter.class);  
  
        //允许跨域  
        http.cors();  
    }
```

## 4. 认证授权失败处理

1. 自定义 `AuthenticationEntryPoint` 认证失败处理器 和 `AccessDeniedHandler` 授权失败处理器

```java
/**  
 * 认证异常处理  
 */  
@Component  
public class AuthenticationEntryPointImpl implements AuthenticationEntryPoint {  
    @Override  
    public void commence(HttpServletRequest request, HttpServletResponse response, AuthenticationException e) throws IOException, ServletException {  
        e.printStackTrace();  
  
        ResponseResult result = null;  
        if (e instanceof BadCredentialsException) {  
            // 用户名或密码错误  
            result = ResponseResult.errorResult(AppHttpCodeEnum.LOGIN_ERROR.getCode(), e.getMessage());  
        } else if (e instanceof InsufficientAuthenticationException) {  
            // 登录过期  
            result = ResponseResult.errorResult(AppHttpCodeEnum.NEED_LOGIN);  
        } else {  
            result = ResponseResult.errorResult(AppHttpCodeEnum.SYSTEM_ERROR.getCode(), "认证或授权失败");  
        }  
        // 响应给前端  
        WebUtils.renderString(response, JSON.toJSONString(result));  
    }  
}
```

```java
/**  
 * 权限异常处理  
 */  
@Component  
public class AccessDeniedHandlerImpl implements AccessDeniedHandler {  
    @Override  
    public void handle(HttpServletRequest request, HttpServletResponse response, AccessDeniedException e) throws IOException, ServletException {  
        e.printStackTrace();  
  
        ResponseResult result = ResponseResult.errorResult(AppHttpCodeEnum.NO_OPERATOR_AUTH);  
        // 响应给前端  
        WebUtils.renderString(response, JSON.toJSONString(result));  
    }  
}
```

2. 配置文件 `SecurityConfig` 中配置认证和授权异常处理器

```java
    @Override  
    protected void configure(HttpSecurity http) throws Exception {  
		// ...
		
        // 配置认证和权限异常处理器  
        http.exceptionHandling()  
                        .authenticationEntryPoint(authenticationEntryPoint)  
                                .accessDeniedHandler(accessDeniedHandler);  
  
		// ...
    }
```

## 5. 全局异常处理

自定义异常类

```java
public class SystemException extends RuntimeException{  
  
    private int code;  
  
    private String msg;  
  
    public int getCode() {  
        return code;  
    }  
  
    public String getMsg() {  
        return msg;  
    }  
  
    public SystemException(AppHttpCodeEnum httpCodeEnum) {  
        super(httpCodeEnum.getMsg());  
        this.code = httpCodeEnum.getCode();  
        this.msg = httpCodeEnum.getMsg();  
    }  
  
}
```

异常处理器

```java
@RestControllerAdvice  
@Slf4j  
public class GlobalExceptionHandler {  
  
    /**  
     * 处理自定义的异常SystemException  
     * @param e  
     * @return  
     */  
    @ExceptionHandler(SystemException.class)  
    public ResponseResult systemExceptionHandler(SystemException e) {  
        // 打印异常信息  
        log.error("出现了异常: {}", e);  
        return ResponseResult.errorResult(e.getCode(), e.getMsg());  
    }  
  
    /**  
     * 处理剩余的全局异常  
     * @param e  
     * @return  
     */  
    @ExceptionHandler(Exception.class)  
    public ResponseResult exceptionHandler(Exception e) {  
        // 打印异常信息  
        log.error("出现了异常: {}", e);  
        return ResponseResult.errorResult(AppHttpCodeEnum.SYSTEM_ERROR.getCode(), e.getMessage());  
    }  
}
```

# 七、注销

* 注销只需要删除redis缓存中该userid对应的数据即可，之后所有请求在校验过滤器中都会由于redis中没数据而被过滤

控制类 `BlogLoginController`

```java
/**  
 * 注销  
 * @return  
 */  
@PostMapping("/logout")  
public ResponseResult logout() {  
    return blogLoginService.logout();  
}
```

业务类 `BlogLoginServiceImpl`

```java
@Override  
public ResponseResult logout() {  
    // 1.获取token并解析得到userid  
    Authentication authentication = SecurityContextHolder.getContext().getAuthentication();  
    LoginUser loginUser = (LoginUser) authentication.getPrincipal();  
    Long userId = loginUser.getUser().getId();  
  
    // 2.删除redis中的用户信息  
    redisCache.deleteObject("bloglogin:" + userId);  
  
    return ResponseResult.okResult();  
}
```

同时需要配置文件中关闭默认登出功能

```java
@Override  
protected void configure(HttpSecurity http) throws Exception {  
	// ...
    // 关闭默认的退出登录功能  
    http.logout().disable();  
	// ...
}
```

# 八、分页查询评论

评论包括根评论和子评论，每条子评论可以评论指定用户/评论

## 1. 文章评论

1. 控制类 `CommentController` 和业务类 `CommentServiceImpl`

```java
@Autowired  
private CommentService commentService;  
  
/**  
 * 分页获取该文章的评论  
 * @param articleId  
 * @param pageNum  
 * @param pageSize  
 * @return  
 */  
@GetMapping("/commentList")  
public ResponseResult commentList(Long articleId, Integer pageNum, Integer pageSize) {  
    return commentService.commentList(articleId, pageNum, pageSize);  
}
```

```java
@Service  
public class CommentServiceImpl extends ServiceImpl<CommentMapper, Comment>  
    implements CommentService{  
  
    @Autowired  
    private UserService userService;  
  
    /**  
     * 分页获取该文章的评论  
     * @param articleId  
     * @param pageNum  
     * @param pageSize  
     * @return  
     */  
    @Override  
    public ResponseResult commentList(Long articleId, Integer pageNum, Integer pageSize) {  
        // 1.分页查询所有根评论  
        Page<Comment> pageInfo = new Page<>(pageNum, pageSize);  
        LambdaQueryWrapper<Comment> queryWrapper = new LambdaQueryWrapper<>();  
        queryWrapper.eq(Comment::getArticleId, articleId);  
        queryWrapper.eq(Comment::getRootId, -1);  
        queryWrapper.orderByDesc(Comment::getCreateTime);  
        this.page(pageInfo, queryWrapper);  
  
        // 2.构造CommentVo并填充里面字段来返回  
        List<CommentVo> commentVoList = toCommentVoList(pageInfo.getRecords());  
  
        // 3.查询子评论并填充  
        commentVoList.forEach(item -> {  
            List<CommentVo> children = getChildren(item.getId());  
            item.setChildren(children);  
        });  
  
        return ResponseResult.okResult(new PageVo(commentVoList, pageInfo.getTotal()));  
    }  
  
    /**  
     * 查询并填充用户名字段  
     * @param list  
     * @return  
     */  
    private List<CommentVo> toCommentVoList(List<Comment> list) {  
        // 1.拷贝到CommentVo列表中  
        List<CommentVo> commentVos = BeanCopyUtils.copyBeanList(list, CommentVo.class);  
  
        // 2.查询并填充用户名字段 以及 评论对象用户名  
        commentVos.forEach(item -> {  
            // 查询并填充用户名  
            String nickName = userService.getById(item.getCreateBy()).getNickName();  
            item.setUsername(nickName);  
            // 如果是评论其他用户就填充对应的用户名  
            if (item.getToCommentId() != -1) {  
                String toCommentName = userService.getById(item.getToCommentUserId()).getNickName();  
                item.setToCommentUserName(toCommentName);  
            }  
        });  
  
        return commentVos;  
    }  
  
    /**  
     * 获取子评论并构造成Vo  
     * @param rootId  
     * @return  
     */  
    private List<CommentVo> getChildren(Long rootId) {  
        // 1.查询子评论  
        LambdaQueryWrapper<Comment> queryWrapper = new LambdaQueryWrapper<>();  
        queryWrapper.eq(Comment::getRootId, rootId);  
        queryWrapper.orderByDesc(Comment::getUpdateTime);  
        List<Comment> comments = this.list(queryWrapper);  
  
        // 2.构造CommentVo返回  
        List<CommentVo> commentVos = toCommentVoList(comments);  
        return commentVos;  
    }  
}
```

## 2. 友链评论

友链评论和文章评论类似，所以只需要用前面文章评论的函数再稍加修改即可

1. 控制类 `CommentController` 和业务类 `CommentServiceImpl`

```java
/**  
 * 友链评论列表  
 * @param pageNum  
 * @param pageSize  
 * @return  
 */  
@GetMapping("/linkCommentList")  
public ResponseResult linkCommentList(Integer pageNum, Integer pageSize) {  
    return commentService.commentList(SystemConstants.LINK_COMMENT, null, pageNum, pageSize);  
}
```

```java
@Override  
public ResponseResult commentList(String commentType, Long articleId, Integer pageNum, Integer pageSize) {  
	// ...
    // 如果是文章就需要获取指定文章的评论  
    queryWrapper.eq(SystemConstants.ARTICLE_COMMENT.equals(commentType), Comment::getArticleId, articleId);  
    // 获取指定类型的评论  
    queryWrapper.eq(Comment::getType, commentType);  
    // ...
}
```

# 九、发表评论

1. 控制类 `CommentController` 和业务类 `CommentServiceImpl`

```java
/**  
 * 添加评论  
 * @param comment  
 * @return  
 */  
@PostMapping  
public ResponseResult addComment(@RequestBody Comment comment) {  
    return commentService.addComment(comment);  
}
```

```java
@Override  
public ResponseResult addComment(Comment comment) {  
    // 评论内容不能为空  
    if (!StringUtils.hasText(comment.getContent())) {  
        throw new SystemException(AppHttpCodeEnum.CONTENT_NOT_NULL);  
    }  
    // 保存评论  
    save(comment);  
    return ResponseResult.okResult();  
}
```

## mp自动填充字段

1. 添加处理类来处理插入和更新字段

```java
@Component  
public class MyMetaObjectHandler implements MetaObjectHandler {  
    @Override  
    public void insertFill(MetaObject metaObject) {  
        Long userId = null;  
        try {  
            // 获取当前用户id  
            userId = SecurityUtils.getUserId();  
        } catch (Exception e) {  
            // TODO 如果没有登录就发表需要提示登陆后才能发表  
            e.printStackTrace();  
            userId = -1L;//表示是自己创建  
        }  
        this.setFieldValByName("createTime", new Date(), metaObject);  
        this.setFieldValByName("createBy",userId , metaObject);  
        this.setFieldValByName("updateTime", new Date(), metaObject);  
        this.setFieldValByName("updateBy", userId, metaObject);  
    }  
  
    @Override  
    public void updateFill(MetaObject metaObject) {  
        this.setFieldValByName("updateTime", new Date(), metaObject);  
        this.setFieldValByName(" ", SecurityUtils.getUserId(), metaObject);  
    }  
}
```

2. 有需要的实体类字段添加注解

```java
// entity/Comment.java
@Data  
@NoArgsConstructor  
@AllArgsConstructor  
@TableName("sg_comment")  
public class Comment implements Serializable {
	// ...
	/**  
	 * 创建人的用户id  
	 */@TableField(fill = FieldFill.INSERT)  
	private Long createBy;  
	  
	/**  
	 * 创建时间  
	 */  
	@TableField(fill = FieldFill.INSERT)  
	private Date createTime;  
	  
	/**  
	 * 更新的用户id  
	 */@TableField(fill = FieldFill.INSERT_UPDATE)  
	private Long updateBy;  
	  
	/**  
	 * 更新时间  
	 */  
	@TableField(fill = FieldFill.INSERT_UPDATE)  
	private Date updateTime;
	// ...
}
```

# 十、个人信息查询与更新

## 1. 查询

1. 控制类 `UserController` 和 业务类 `UserServiceImpl`

```java
/**  
 * 查询用户信息  
 * @return  
 */  
@GetMapping("/userInfo")  
public ResponseResult userInfo() {  
    return userService.userInfo();  
}
```

```java
@Override  
public ResponseResult userInfo() {  
    // 1.从认证信息中获取userId  
    Long userId = SecurityUtils.getUserId();  
  
    // 2.从数据库中查询  
    User user = this.getById(userId);  
    UserInfoVo userInfoVo = BeanCopyUtils.copyBean(user, UserInfoVo.class);  
    return ResponseResult.okResult(userInfoVo);  
}
```

## 2. 更新

```java
/**  
 * 更新用户信息  
 * @param user  
 * @return  
 */  
@PutMapping("/userInfo")  
public ResponseResult updateUserInfo(@RequestBody User user) {  
    return userService.updateUserInfo(user);  
}
```

```java
@Override  
public ResponseResult updateUserInfo(User user) {  
    this.updateById(user);  
    return ResponseResult.okResult();  
}
```

## 3. 图片上传

使用阿里云OSS来存储上传的图片，参考[[案例1.员工部门管理系统#2. 阿里云OSS|tlias中使用阿里云OSS]]来使用

1. 控制类 `UploadController` 和 业务类 `OSSUploadService`

```java
@PostMapping("/upload")  
public ResponseResult uploadImg(MultipartFile img) throws IOException {  
    return uploadService.uploadImg(img);  
}
```

```java
@Service  
@Slf4j  
public class OSSUploadService implements UploadService {  
  
    @Autowired  
    private AliOSSUtils aliOSSUtils;  
  
    /**  
     * 上传图片到阿里OSS  
     * @param img  
     * @return  
     * @throws IOException  
     */    @Override  
    public ResponseResult uploadImg(MultipartFile img) throws IOException {  
        // 上传文件到阿里OSS  
        log.info("文件上传，文件名:{}", img.getOriginalFilename());  
        String url = aliOSSUtils.upload(img);  
        log.info("文件上传完成，文件访问的url为:{}", url);  
        return ResponseResult.okResult(url);  
    }  
}
```

# 十一、用户注册

1. 控制类 `UserController` 和 业务类 `UserServiceImpl`

```java
/**  
 * 用户注册  
 * @param user  
 * @return  
 */  
@PostMapping("/register")  
public ResponseResult register(@RequestBody User user) {  
    return userService.registry(user);  
}
```

```java
@Override  
public ResponseResult registry(User user) {  
    // 1.对数据进行非空判断  
    if (!StringUtils.hasText(user.getUserName())) {  
        throw new SystemException(AppHttpCodeEnum.USERNAME_NOT_NULL);  
    }  
    if (!StringUtils.hasText(user.getNickName())) {  
        throw new SystemException(AppHttpCodeEnum.NICKNAME_NOT_NULL);  
    }  
    if (!StringUtils.hasText(user.getPassword())) {  
        throw new SystemException(AppHttpCodeEnum.PASSWORD_NOT_NULL);  
    }  
    if (!StringUtils.hasText(user.getEmail())) {  
        throw new SystemException(AppHttpCodeEnum.EMAIL_NOT_NULL);  
    }  
  
    // 2.判断用户是否存在  
    if (existUserName(user.getUserName())) {  
        throw new SystemException(AppHttpCodeEnum.USERNAME_EXIST);  
    }  
  
    // 3.对密码进行加密  
    String encodePassword = passwordEncoder.encode(user.getPassword());  
    user.setPassword(encodePassword);  
  
    // 4.存入数据库  
    this.save(user);  
    return ResponseResult.okResult();  
}  
  
/**  
 * 判断用户名是否已存在  
 * @param userName  
 * @return  
 */  
private boolean existUserName(String userName) {  
    LambdaQueryWrapper<User> queryWrapper = new LambdaQueryWrapper<>();  
    queryWrapper.eq(User::getUserName, userName);  
    return this.count(queryWrapper) > 0;  
}
```

# 十二、AOP实现日志记录

1. 自定义注解 `SystemLog`，加了该注解的方法记为切入点，会打印日志信息

```java
/**  
 * 自定义的需要打印log信息的注解  
 */  
@Retention(RetentionPolicy.RUNTIME)  
@Target({ElementType.METHOD})  
public @interface SystemLog {  
    String businessName();  
}
```

2. 定义AOP类 `LogAspect` 来打印方法相关信息

```java
@Component  
@Aspect  
@Slf4j  
public class LogAspect {  
  
    /**  
     * 切入点  
     */  
    @Pointcut("@annotation(com.sj.annotation.SystemLog)")  
    public void pt() {}  
  
    /**  
     * 通知  
     */  
    @Around("pt()")  
    public Object printLog(ProceedingJoinPoint joinPoint) throws Throwable {  
        Object ret = null;  
  
        try {  
            handleBefore(joinPoint);  
            ret = joinPoint.proceed();  
            handleAfter(ret);  
        } finally {  
            // 结束后换行  
            log.info("=======End=======" + System.lineSeparator());  
        }  
  
        return ret;  
    }  
  
    private void handleBefore(ProceedingJoinPoint joinPoint) {  
  
        // 1.获得请求头等信息  
        ServletRequestAttributes requestAttributes = (ServletRequestAttributes) RequestContextHolder.getRequestAttributes();  
        HttpServletRequest request = requestAttributes.getRequest();  
  
        // 2.获取后端的调用的方法签名，然后可以通过其获得方法名、注解等  
        MethodSignature methodSignature = (MethodSignature) joinPoint.getSignature();  
  
        log.info("=======Start=======");  
        // 打印请求 URL        
        log.info("URL            : {}", request.getRequestURL());  
        // 打印描述信息  
        log.info("BusinessName   : {}", methodSignature.getMethod().getAnnotation(SystemLog.class).businessName());  
        // 打印 Http method        
        log.info("HTTP Method    : {}", request.getMethod());  
        // 打印调用 controller 的全路径以及执行方法  
        log.info("Class Method   : {}.{}", methodSignature.getDeclaringTypeName(), methodSignature.getName());  
        // 打印请求的 IP        
        log.info("IP             : {}", request.getRemoteHost());  
        // 打印请求入参  
        log.info("Request Args   : {}", JSON.toJSONString(joinPoint.getArgs()));  
    }  
  
    private void handleAfter(Object ret) {  
        // 打印出参  
        log.info("Response       : {}", JSON.toJSONString(ret));  
    }  
}
```

# 十三、更新浏览次数

思路：读取和写入浏览次数从redis中读取写入，然后再定期写入mysql中，这样能够减少写入mysql导致同时访问出现卡顿

1. 应用**启动时**将博客的浏览量**从mysql存储到redis中**
2. 更新浏览量时去**更新redis中的数据**
3. **定期**将redis中浏览量**更新**到mysql数据库中
4. 读取浏览量时**从redis中读取**

## 1. 项目启动时执行

自定义类 `ViewCountRunner` 实现接口 `CommandLineRunner`，重写里面的方法 `run()` ，其会在启动项目后执行

```java
@Component  
public class ViewCountRunner implements CommandLineRunner {  
  
    @Autowired  
    private ArticleService articleService;  
  
    @Autowired  
    private RedisCache redisCache;  
  
    /**  
     * 启动时将数据库中文章浏览量存储到redis中  
     * @param args  
     * @throws Exception  
     */    @Override  
    public void run(String... args) throws Exception {  
        // 1.查询博客信息  id -> viewCount        List<Article> articles = articleService.list();  
        Map<String, Integer> viewCountMap = articles.stream()  
                .collect(Collectors.toMap(  
                        article -> article.getId().toString(),  
                        article -> article.getViewCount().intValue()  
                ));  
  
        // 2.存储到redis中  
        redisCache.setCacheMap("article:viewCount", viewCountMap);  
    }  
}
```

## 2. 更新redis中的浏览量

1. 控制类 `ArticleController` 和业务类 `ArticleSericeImpl`

```java
/**  
 * 更新文章浏览量  
 * @param id  
 * @return  
 */  
@PutMapping ("/updateViewCount/{id}")  
public ResponseResult updateViewCount(@PathVariable("id") Long id) {  
    return articleService.updateViewCount(id);  
}
```

```java
/**  
 * redis中更新文章浏览量  
 * @param id  
 * @return  
 */  
@Override  
public ResponseResult updateViewCount(Long id) {  
    redisCache.incrementCacheMapValue("article:viewCount", id.toString(), 1);  
    return ResponseResult.okResult();  
}
```

2. `redisCache` 中的更新方法

```java
/**  
 * 更新文章浏览量  
 * @param key  
 * @param id  
 * @param v  
 */  
public void incrementCacheMapValue(String key, String id, int v) {  
    redisTemplate.opsForHash().increment(key, id, v);  
}
```

## 3. 定时任务

可以通过cron表达式加注解 `@Scheduled()` 到指定方法上来定时执行，并且可以配置任务执行的时间

1. 前台启动类添加注解 `@EnableScheduling` 来开启定时任务
2. 定期将redis中的内容存储到mysql数据库中

```java
@Component  
public class UpdateViewCountJob {  
  
    @Autowired  
    private RedisCache redisCache;  
  
    @Autowired  
    private ArticleService articleService;  
  
    /**  
     * 定期将redis中文字浏览量存储到mysql数据库中  
     */  
    // 每隔一分钟更新一次  
    @Scheduled(cron = "0 0/1 * * * ?")
    public void updateViewCount() {  
        // 1.从redis中查询得到所有文章浏览量  
        Map<String, Integer> viewCountMap = redisCache.getCacheMap("article:viewCount");  
        List<Article> articles = viewCountMap.entrySet().stream()  
                .map(entry -> new Article(Long.valueOf(entry.getKey()), entry.getValue().longValue()))  
                .collect(Collectors.toList());    
  
        // 2.存储到redis数据库中  
        articleService.updateBatchById(articles);  
    }  
}
```

### cron表达式

在线cron表达式语法 [quartz/Cron/Crontab表达式在线生成工具-BeJSON.com](https://www.bejson.com/othertools/cron/)

* 7部分组成：秒 分 时 日 月 周 年，空格区分开
	* `*` 表示任意值
	* `,` 分隔列表，如 `1,2,3 * * * * ?` 表示每个第1，2，3秒
	* `-` 范围
	* `/` 每隔多久，如 `5/10` 第5秒开始每隔10秒
	* 特殊值：
		* `?` 没有具体值，日期和星期可以用，且一个设置了值另一个必须使用
		* `L` 最后一天，日期和星期可以用（星期六是最后）

## 4. 从redis中读取浏览量

在业务类 `ArticleServiceImpl` 中所有能够查看文章信息的方法都添加从redis中查看浏览量来更新

```java
Integer viewCount = redisCache.getCacheMapValue("article:viewCount", id.toString());  
article.setViewCount(Long.valueOf(viewCount));
```