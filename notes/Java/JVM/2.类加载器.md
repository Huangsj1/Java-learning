# 一、类的生命周期

![[d1a1ebd80f6bb923ed5b16a74edae46.jpg]]

## 1. 加载

1. **类加载器**加载类的字节码信息，包括磁盘上的字节码文件、程序动态代理产生的类、网络传输的类
	* 类加载器是由JVM提供的
2. **JVM**会将字节码信息保存到**方法区**中，生成一个 `InstanceKlass`对象保存类的所有信息，同时还包括**虚方法表**（多态）
3. 同时JVM还会在**堆中创建一份与方法区类似的 `java.lang.Class` 对象**（和其他创建的对象类似），用于Java代码中去获取**类的信息和静态变量信息**
	1. 对于其它语言编写的类（如C++）信息，Java程序不能够直接读取，所以需要通过在方法区中创建一个对应的 `Class` 对象来统一读取
	2. 堆区中的 `Class` 数据少于方法区的 `InstanceKlass` 完整的内容，更安全

![[c73c71f796f1c45b8a7153a76935ccf.jpg]]

## 2. 连接

### 1. 验证

校验Java字节码文件**是否遵循规范**：文件格式、元信息、符号是否正确引用等（其中检验字节码文件需要检验较多内容，所以采用的是**分段检查**：在加载的时候会先进行一些结构性检查，等到加载完类后再进行更完整的验证操作）

### 2. 准备

给堆中的 `Class` 对象中的**静态变量分配内存并赋初始值**（如果用 `final`修饰就变成常量，初始值就会是常量值，否则初始值为默认值）

不在加载的时候就准备是因为要经过验证检查是否有问题，没问题再分配内存准备数据

### 3. 解析

将常量池中的符号引用 `#数字` 替换为**直接引用**（使用地址）：加载之后类的常量池中已经在固定的地址了，所以代码中的符号引用可以直接替换为地址引用

## 3. 初始化

* 会执行**静态代码块中的代码**，并且为**静态变量赋值**
	* 实际执行的是字节码文件中的 `clinit` 方法的字节码指令（`main`方法是主函数方法，`init`方法是构造方法，`clinit`方法是初始化类方法），包括所有的**静态变量初始化**和**静态代码块**
		* 执行的顺序和java代码**书写顺序**一致

![[521677ae7256be38ca3913d69ab7ee9.jpg]]

类的初始化只有在**首次使用的时候**才会执行：

1. 访问类的静态变量/静态方法（访问 `final`修饰的常量不会触发）
	* 访问父类的静态变量/静态方法**只会初始化父类**，不会初始化子类（除非创建一个子对象/访问子类静态变量/静态方法）
2. `new` 一个对象
3. 反射
4. 调用方法 `Class.forName("类的限定名")`
	* 会使用当前类的类加载器来加载对应的类并且执行连接和初始化
	* 直接使用 `Classloader类对象.loadClass("类的限定名")`只会加载

![[a51832b5cb6d46c853843eec57e3e8f.jpg]]

# 二、类加载器

类加载器负责在类加载的过程中将类的**字节码文件加载到内存中放到 `byte[]` 数组里面**，接着**调用JVM底层的方法将 `byte[]` 转换成方法区和堆中的数据**

![[3c981159ace1e5351c098c8747d60c6.jpg]]

## 1. 类加载器分类

![[5571260d5681bcb08a028c79dda1245.jpg]]![[4d60d66e879424805a5254f66490527.jpg]]

### 1. 启动类加载器

启动类加载器是**虚拟机提供的C++编写的类加载器**，默认会**加载Java安装目录 `/jre/lib` 下的核心的jar包中类文件**（核心jar包 -> jvm）

* 我们无法通过`Class`对象来获得启动类加载器，得到的会是 `null`，因为它是由虚拟机提供的，不允许我们获得来使用

![[6203f8343ad39573a3772881c284d98.jpg]]

### 2. 扩展类加载器

**jdk提供的Java编写的类加载器**，默认加载**Java安装目录的 `/jre/lib/ext`下的扩展的jar包中类文件**（扩展/通用的非核心jar包 -> jdk）

![[bb96d468af71ac5c557ab4f276c1bb4.jpg]]

### 3. 应用程序加载器

加载**项目中生成的字节码文件**（自己编写的）和**第三方依赖中的jar包的字节码文件**（项目中的类和第三方依赖jar包 -> 自己写的）

![[8bed935c212b38bc99d59323ad375be.jpg]]

## 2. 双亲委派机制

主要解决一个类到底由**谁来加载**的问题

作用：

1. 避免恶意代码替换jdk中核心类库，如自己编写的 `java.lang.String` 类来替换核心类库中的 `String` 类
2. 避免一个类被重复加载

![[3053d9d22e1d539fcdb81d32453ec92.jpg]]![[61b0e1067180f106992a5596d37968f.jpg]]

### 手动进行类加载

![[d5fbab8b6b14bae20d6b39253202d02.jpg]]

## 3. 打破双亲委派机制

如果两个不同的应用有相同限定名的类，如果采用双亲委派机制会导致第二个类无法加载，所以需要打破双亲委派机制来手动加载类

![[b3cd29b24ccf357b1113880dc27f552.jpg]]

### 1. 自定义类加载器

1. 定义一个类继承 `ClassLoader` 类
2. 重写 `loadClass()` 方法和 `findClass()`方法，不再将加载过程交给父类加载器，而是调用自己的类加载方法 `findClass()` 加载类

![[4306a12eb6c23c697f5a9d40f86636d.jpg]]

* 默认父类加载器为系统的应用程序加载器
* 不同类加载器加载的相同限定名的类处在不同的方法区和堆的位置，它们被不同类加载器加载，所以不属于相同的类

![[c3bd583d7107732942c567a4c28cf84.jpg]]![[de2acf5848892d4ad798fac6c0eb704.jpg]]

### 2. 线程上下文类加载器

在启动类加载器中加载 `DriverManager`的时候，通过**直接获取当前线程上下文的类加载器——应用程序类加载器**，来实现类加载（这一步加载还是会走双亲委派机制，但是总体来看是启动类加载器调用了应用程序类加载器，打破了双亲委派机制）

![[d3740ebfe3029d91db5d0cd9eec2260.jpg]]![[6f652b65e4e0288b93eab3d0d070f75.jpg]]

其实也可以看作没有打破双亲委派机制

![[68991cd1b156149fff2375efab2ecba.jpg]]

### 3. Osgi框架的类加载器

![[e92dbc5d740989b14e7fbfeafb01d93.jpg]]

![[84bfaf4587a7f7d2fcddb17f6e91dba.jpg]]![[Pasted image 20240310172351.png]]

## 4. jdk9及之后

![[d5e943b6b8532c25bfa0dba93e240c5.jpg]]

![[d12a1b6ba0fa88f16748c3319e1910b.jpg]]![[ab2e660a4f6c1f2e93b21d0feba4546.jpg]]