# 一、内存区域

* 线程私有：
	1. 程序计数器：一块存储了当前java线程运行到的地址的**内存**
	2. 虚拟机栈：保存java方法执行过程中的**栈帧**（成员变量、参数、返回地址、返回值等）
		* 每个方法一个栈帧
	3. 本地方法栈：JVM调用一些本地方法（其他语言编写的方法）过程中保存的栈帧
* 线程公共：
	1. 堆：创建的对象等都是存储在堆中的
	2. 方法区（逻辑命名）：存储了类结构相关信息（运行时常量池、变量、方法、方法代码），jdk7时称为**永久代放在堆**里面，jdk8时称为**元空间移出了堆放到了本地内存**
		1. 放在堆里本来堆就只有一定内存，放了方法区后方法区内存基本固定，且堆中剩余内存也少了，方法区和堆都容易出现内存溢出
		2. 放在本地内存中当需要更多内存时JVM就可以向操作系统申请，不容易出现内存溢出
* 本地内存：除了上面部分由JVM向操作系统请求来自行管理的内存之外的内存（手动管理java线程对内存的分配和释放）；本地内存也是由JVM申请分配来使用的，但不会对这部分内存进行更高层次的分配和释放
	1. **元空间**的内存是由JVM来申请和释放的，属于JVM对本地内存的管理
	2. **直接内存**则需要程序员使用特定的API来分配的，并在对应的对象经过垃圾回收的时候释放（不是通过GC释放，而是**调用指定的回调函数主动释放直接内存**）
		* 直接内存相当于JVM向操作系统通过mmap分配的一块能够**直接映射文件内容的内存**：java程序通过`ByteBuffer.allocateDirect()`方法向系统申请一块直接内存时，JVM会在在堆中通过创建`DirectByteBuffer`对象，并通过系统调用`mmap`分配一块直接映射文件的内存，DirectByteBuffer对象里引用了这块内存来直接使用
		* 通过直接内存操作系统只需要**将文件内容拷贝一次**到mmap直接映射内存中即可；而如果java程序直接读写文件需要在堆中创建数组缓冲区，操作系统需要先拷贝到内核空间，再拷贝到用户空间，**文件内容总共拷贝两次**

## 1. 虚拟机栈

每个线程都有一个私有的虚拟机栈，栈中为每个方法都分配一个栈帧

### 栈帧

![[f0447523f80e3d5ec3c7a39c25c43dc.jpg]]

#### 1. 局部变量表

方法执行的时候存放所有的局部变量：this对象、方法参数、方法体的局部变量

字节码文件中的局部变量表：

![[8229bf2e93c7c49cf4f0c60377a6e4d.jpg]]

栈帧中的局部变量表：

1. `long` 和 `double` 类型占用两个槽，其他类型占用一个槽
2. 对于不再生效的局部变量的位置会被覆盖使用

![[d56c8a39748e0efe150da51a3755ab6.jpg]]![[677e7dc8f69a3818239f9f4b5927936.jpg]]

#### 2. 操作数栈

存放**中间数据**的一块区域，编译的时候就可以确定大小

![[e90efbf55f272653beba3faa6561e28.jpg]]

#### 3. 帧数据

包括**动态链接、方法出口、异常表**

![[1ca1194dea4ad259d7651d2631a2f17.jpg]]![[312cc72bfbeee823b20f66830ed45a2.jpg]]![[609d13bd696502f57f1dcf240f91168.jpg]]

## 2. 本地方法栈

Hotspot虚拟机中本地方法栈也是存放在虚拟机栈

![[0bb775ae6102907e7f2c9bfacdcb415.jpg]]

## 3. 堆内存

存放的是**对象**和**静态变量**（jdk1.7及之后）

![[7f1b2919bb10c4a89f9d7b202d6de3f.jpg]]

创建一个新的线程会创建一个新的虚拟机栈，其需要执行的内容和原来线程不一样，且不能够访问原来线程的栈中的局部变量（也就得不到对应的堆中的对象），但是可以通过传参给新线程来访问堆中的变量

## 4. 方法区

* jdk6及之前称为**永久代放在堆**里面：包含了类的元信息、字符串常量池（逻辑包含于运行时常量池）、运行时常量池、静态变量、JIT代码缓存
* jdk7时也称为**永久代放在堆**里面：包含了类信息、运行时常量池、JIT代码缓存；将字符串常量池、静态变量移到了堆中
* jdk8时称为**元空间移出了堆放到了本地内存**：包含了类信息、运行时常量池、JIT代码缓存

### 1. 运行时常量池

JVM在类加载的时候，会将 `.class` 文件中的**常量池信息**加载到运行时常量池中，并将方法中用到的 `#数字` **改写成对应常量存放的内存地址**

### 2. 字符串常量池 StringTable（下面是根据jdk6来讨论的）

> **jdk1.6**及之前字符串常量池中存储的是**实际的String对象**；**jdk1.7**及之后存储的是**堆中String对象的引用**

class文件的常量池中**字符串字面量**在被方法中的代码**使用的时候会加载到字符串常量池 `StringTable[]` 中**，例如 `ldc #2` 会将符号 `a` 变为 `"a"` 字符串对象放到 `StringTable["a"]` 中

* `StringTable[]` 是哈希表结构，对符号进行映射来存放，不能扩容（实际上**存储的是String对象**，里面的`value[]`数组中存储着字符串）
* 编译期间会将 `"a" + "b"` 这些常量直接转为 `"ab"`
* 只有在**执行到使用字符串常量指令的时候才会创建字符串对象**：
	* 每次使用到字符串常量的时候首先哈希到 `StringTable[]` 中**查看是否存在**，存在就直接返回字符串对象，不存在就先创建字符串对象再返回
* 当对空间不足的时候，`StringTable[]`也是会进行垃圾回收的

#### 1. String类的使用
	
jdk1.6和jdk1.7的举例可以参考[String——常量池与 intern](https://zhuanlan.zhihu.com/p/107781993)

1. `String s1 = "a"`：在**字符串常量池中创建String对象**（如果没有），该对象的 `value[]` 也是在常量池中创建的，然后返回地址给成员变量引用
	* `String s11 = "a" + "b"`：编译器会优化成 `String s11 = "ab"`
2. `String s2 = new String("a")`：
	1. 该构造方法的参数是`String`类型，实际上传的**参数就是字符串常量池里的String对象的引用**，所以会先在字符串常量池中查看是否 `"a"` 对应的String对象是否存在，不存在就创建（也会创建`value[]`数组），存在就直接返回
	2. 接着会在**堆中创建String对象**，然后将堆中String对象的 `value = 参数.value`，也就是`value[]`数组**引用字符串常量池里的字符串的value**
3. `String s3 = new String("a") + new String("b")`：
	1. 首先创建两个`String`对象（可能也会在字符串常量池创建两个对象）
	2. 然后创建`StringBuilder`对象，其里面的`value[]`在堆中创建了一个字符数组
	3. 然后通过 `append(String)` 方法拼接字符串，将两个 `String` 对象引用到的字符串常量池中的字符数组拷贝到堆中的字符数组中
	4. 最后通过 `toString()` 返回一个在**堆中创建的字符串对象**，该字符串对象会在**堆中创建一个字符数组**赋给 `value[]`，然后将 `StringBuilder`对象中的 `value[]` 中的内容拷贝到该字符串的 `value[]`中
4. `String s4 = s3.intern()`：
	1. 首先检查s3在堆中的字符串对象所使用的字符串是否在字符串常量池中出现（哈希）
	2. 如果存在直接返回该对象
	3. jdk1.6：如果没有出现就在字符串常量池中**创建一个String对象**，其也会**创建新的 `value[]` 数组并拷贝数据**进来
	4. jdk1.7：由于字符串常量池存储的是堆中字符串对象的引用，所以直接将**堆中String对象的引用放到字符串常量池中**

无论是在**堆中创建的String对象**，还是在**字符串常量池中创建的String对象**，二者本质上都是一样的（同一个类）

```java
// 1.直接引用字符串常量池中的字符串对象
String s1 = "a"

// 2.创建String对象，然后将String对象里面的value[]指向字符串常量池的字符串对象的value[]
String s11 = new String("a");
/*
public String(String original) {  
    this.value = original.value;  
    this.hash = original.hash;  
}
*/
// s1 == s2 结果为false，因为二者引用的字符串对象不同
// ------------------------------------------------------------------

// 3.StringBuilder返回String对象
//  3.1创建了StringBuilder对象，其里面的value[]数组在堆中创建了一个字符数组，里面存储了字符串常量池中字符串对象的value[]数组的拷贝
//  3.2最后调用toString()返回一个String对象，其value数组=StringBuilder的value数组，所以最终的String对象的value数组引用的是堆中的字符数组而不是字符串常量池的字符串对象的value数组
String s2 = "b";
String s3 = s1 + s2;
```

下面反编译这段代码：

```java
public class ScannerUse {  
    public static void main (String[] args) throws NoSuchFieldException, IllegalAccessException {  
        String s1 = "a";  
        String s2 = "b";  
        String s3 = "ab";  
        String s11 = new String("a");  
        String s4 = s1 + s2;  
        System.out.println(s1 == s11);  // false
		System.out.println(s3 == s4);   // false
    }  
}
```

![[Pasted image 20240309113836.png]]![[Pasted image 20240309113900.png|300]]

#### 2. 存储位置

* jdk1.6及之前：放在堆的永久代中（逻辑上称为方法区），垃圾回收效率低
* jdk1.7及之后：单独取出来放在堆中，垃圾回收效率高

## 5. 直接内存

### 1. DirectByteBuffer对象

通过调用 `ByteBuffer.allocateDirect()`方法可以向系统申请一块直接内存（直接映射文件内容），这里会创建一个 `DirectByteBuffer` 对象，里面有几个特殊的成员：

* `Unsafe unsafe` 对象：不安全的对象，会调用 `unsafe.allocateMemory(size);` 方法来**分配一块直接内存**
* `Cleaner cleaner` 对象：虚引用对象，当被垃圾回收的时候会触发回调函数来执行 `unsafe.freeMemory(address);` 来**释放直接内存**（所以当`DirectByteBuffer`对象被GC回收的时候，里面的cleaner成员也会被回收，就会调用回调函数释放直接内存）

### 2. Unsafe对象

虽然前面的 `DirectByteBuffer` 对象可以申请直接内存，但是只有等到**被垃圾回收的时候才会回收直接内存**（虽然可以通过 `System.gc()` 来立刻调用垃圾回收，但是这个full GC耗时间，所以一般都会禁用）

可以直接通过使用 `Unsafe` 对象来分配和回收内存：

```java
Unsafe unsafe = getUnsafe();  
// 分配直接内存  
long base = unsafe.allocateMemory(1024);  
unsafe.setMemory(base, 1024, (byte) 0);  
  
// 释放直接内存  
unsafe.freeMemory(base);
```