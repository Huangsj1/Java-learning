# 一、异常

![[2137a3ba93899107670814970dc41d4.jpg]]

* 异常的**作用**：
	1. 检查bug
	2. 可以作为方法内部的一种特殊返回值，通知调用者执行情况
* 异常**处理**：
	1. JVM默认处理方式：打印异常名称、原因、位置到控制台；程序停止执行
	2. 自己处理（捕获异常）：`try{} catch(){} finally{}`
		* 当程序的一些代码可能出现异常，但又不想程序终止时可以用
		* 其中try里面是会出现异常的代码，catch为出现异常后跳转到的代码块，finally不管是否会出现异常都会执行
	1. 常见方法（都是异常类的成员方法）：
		1. `public String getMessage()`：返回详细消息的字符串
		2. `public String toString()`：返回简短描述
		3. `public void printStackTrace()`：红色字体打印异常信息到控制台（不会终止程序），常用
* 出现异常**流程**：
	1. `try`中出现异常会直接创建一个对应异常类型的对象，传递到调用者后面代码中最近的catch中对比看是否可以被接收/捕获，被捕获后执行catch代码块中的代码，执行完后执行`catch`后面的代码
	2. 多个catch的时候会从最近的开始比较选择，所以一般父类`Exception`放在最后捕获异常，且一个异常只选择一个catch执行
	3. `throw`抛出异常后面的代码不会被执行，直接返回
	4. `try`中出现异常后的代码不会被执行
	5. `catch` 未捕获异常就会交给JVM执行默认处理
* **抛出异常**：
	1. `throws`：写在方法定义后面，告诉本方法可能会有哪些异常 `public void 方法名() throws 异常名1, 异常名2... {}`
		* 运行时期异常可以不写，编译时才要写
	2. `throw`：写在方法内，手动抛出异常对象，交给调用者，下面的代码不再执行 `public void 方法名() { throw new Exceptoin("异常信息"); }`
* **自定义异常**：为了让控制台报错信息更加见名知意，继承 `RuntimeException`（运行时异常） 或 `Exception` 类（编译时异常），需要实现空参和带String参构造方法